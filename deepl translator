import asyncio
import aiohttp
import os
import hashlib
from datetime import datetime
from telethon import events
import re

class SafeDeepLTranslator:
    """–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π API –∫–ª—é—á–∞"""
    
    def __init__(self, client):
        self.client = client
        
        # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ API –∫–ª—é—á–∞
        self.api_key = self.get_api_key_safely()
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏
        self.settings = {
            'auto_translate': True,
            'target_language': 'EN',
            'source_language': 'RU',
            'show_original': True,
            'cache_enabled': True,
            'max_text_length': 4000,
        }
        
        # –ö—ç—à –ø–µ—Ä–µ–≤–æ–¥–æ–≤ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤
        self.translation_cache = {}
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = {
            'translations_done': 0,
            'characters_translated': 0,
            'cache_hits': 0,
            'last_translation': None
        }
        
        self.setup_handlers()
    
    def get_api_key_safely(self):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ API –∫–ª—é—á–∞ —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π"""
        api_key = os.getenv('DEEPL_API_KEY')
        
        if not api_key:
            print("‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: DEEPL_API_KEY –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
            print("‚ÑπÔ∏è –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –µ–≥–æ –∫–æ–º–∞–Ω–¥–æ–π: heroku config:set DEEPL_API_KEY='–≤–∞—à_–∫–ª—é—á'")
            return None
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç –∫–ª—é—á–∞ (–ø—Ä–∏–º–µ—Ä–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è)
        if not api_key.startswith('deepL_auth_key_'):
            print("‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: API –∫–ª—é—á –≤—ã–≥–ª—è–¥–∏—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ")
            print("‚ÑπÔ∏è –ö–ª—é—á –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å 'deepL_auth_key_'")
        
        # –°–∫—Ä—ã–≤–∞–µ–º –∫–ª—é—á –≤ –ª–æ–≥–∞—Ö
        masked_key = api_key[:8] + '...' + api_key[-4:] if len(api_key) > 12 else '***'
        print(f"‚úÖ DeepL API –∫–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω: {masked_key}")
        
        return api_key
    
    def setup_handlers(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–æ–±—â–µ–Ω–∏–π"""
        
        @self.client.on(events.NewMessage(outgoing=True))
        async def translation_handler(event):
            """–ü–µ—Ä–µ–≤–æ–¥ –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
            if not self.settings['auto_translate']:
                return
            
            if not self.api_key:
                await event.reply("‚ùå DeepL API –∫–ª—é—á –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω!")
                return
            
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
            message = event.message.message
            if not message or len(message.strip()) == 0:
                return
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —è–∑—ã–∫ (—Ç–æ–ª—å–∫–æ —Ä—É—Å—Å–∫–∏–π -> –∞–Ω–≥–ª–∏–π—Å–∫–∏–π)
            if self.is_russian_text(message):
                await self.translate_and_send(event, message)
        
        @self.client.on(events.NewMessage(pattern='!translate (.*)'))
        async def manual_translation_handler(event):
            """–†—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥ –ø–æ –∫–æ–º–∞–Ω–¥–µ"""
            if not self.api_key:
                await event.reply("‚ùå DeepL API –∫–ª—é—á –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω!")
                return
            
            text_to_translate = event.pattern_match.group(1)
            if text_to_translate:
                translated = await self.translate_text(text_to_translate)
                if translated:
                    await event.reply(f"üá∑üá∫ ‚Üí üá∫üá∏\n{translated}")
                else:
                    await event.reply("‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞")
        
        @self.client.on(events.NewMessage(pattern='!translator (on|off|status)'))
        async def settings_handler(event):
            """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞"""
            command = event.pattern_match.group(1).lower()
            
            if command == 'on':
                self.settings['auto_translate'] = True
                await event.reply("‚úÖ –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ –≤–∫–ª—é—á–µ–Ω")
            
            elif command == 'off':
                self.settings['auto_translate'] = False
                await event.reply("‚úÖ –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ –≤—ã–∫–ª—é—á–µ–Ω")
            
            elif command == 'status':
                status = "üü¢ –í–ö–õ" if self.settings['auto_translate'] else "üî¥ –í–´–ö–õ"
                stats_text = self.get_stats_text()
                await event.reply(f"üìä –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫: {status}\n\n{stats_text}")
    
    def is_russian_text(self, text):
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç —Ä—É—Å—Å–∫–∏–º"""
        # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –∫–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫–∏–º —Å–∏–º–≤–æ–ª–∞–º
        russian_chars = sum(1 for char in text if '–∞' <= char.lower() <= '—è' or char in '—ë–Å')
        total_chars = sum(1 for char in text if char.isalpha())
        
        if total_chars == 0:
            return False
        
        russian_ratio = russian_chars / total_chars
        return russian_ratio > 0.5  # –ï—Å–ª–∏ –±–æ–ª—å—à–µ 50% —Ä—É—Å—Å–∫–∏—Ö –±—É–∫–≤
    
    def get_cache_key(self, text):
        """–°–æ–∑–¥–∞–µ—Ç –∫–ª—é—á –¥–ª—è –∫—ç—à–∞"""
        return hashlib.md5(f"{text}_{self.settings['target_language']}".encode()).hexdigest()
    
    async def translate_text(self, text):
        """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥–∞ —á–µ—Ä–µ–∑ DeepL API"""
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª–∏–Ω—ã —Ç–µ–∫—Å—Ç–∞
        if len(text) > self.settings['max_text_length']:
            text = text[:self.settings['max_text_length']] + "..."
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—ç—à–∞
        cache_key = self.get_cache_key(text)
        if self.settings['cache_enabled'] and cache_key in self.translation_cache:
            self.stats['cache_hits'] += 1
            return self.translation_cache[cache_key]
        
        try:
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ DeepL API
            url = "https://api-free.deepl.com/v2/translate"
            
            params = {
                'auth_key': self.api_key,
                'text': text,
                'target_lang': self.settings['target_language'],
                'source_lang': self.settings['source_language'],
                'preserve_formatting': '1',
                'split_sentences': '1',
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, data=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        if 'translations' in data and len(data['translations']) > 0:
                            translated_text = data['translations'][0]['text']
                            
                            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
                            if self.settings['cache_enabled']:
                                self.translation_cache[cache_key] = translated_text
                                # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∫—ç—à–∞
                                if len(self.translation_cache) > 1000:
                                    self.translation_cache.pop(next(iter(self.translation_cache)))
                            
                            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                            self.stats['translations_done'] += 1
                            self.stats['characters_translated'] += len(text)
                            self.stats['last_translation'] = datetime.now()
                            
                            return translated_text
                    
                    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
                    error_text = await response.text()
                    print(f"DeepL API Error {response.status}: {error_text}")
                    return None
                    
        except Exception as e:
            print(f"Translation error: {e}")
            return None
    
    async def translate_and_send(self, event, original_text):
        """–ü–µ—Ä–µ–≤–æ–¥–∏—Ç —Ç–µ–∫—Å—Ç –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç"""
        try:
            # –ü–µ—Ä–µ–≤–æ–¥–∏–º —Ç–µ–∫—Å—Ç
            translated = await self.translate_text(original_text)
            
            if not translated:
                return
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
            if self.settings['show_original']:
                response = (
                    f"**üá∑üá∫ –û—Ä–∏–≥–∏–Ω–∞–ª:**\n"
                    f"{original_text}\n\n"
                    f"**üá∫üá∏ –ü–µ—Ä–µ–≤–æ–¥:**\n"
                    f"{translated}\n\n"
                    f"_ü§ñ –ü–µ—Ä–µ–≤–µ–¥–µ–Ω–æ —á–µ—Ä–µ–∑ DeepL_"
                )
            else:
                response = translated
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–≤–æ–¥
            await event.reply(response, parse_mode='md')
            
            # –ú–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥
            # await event.delete()
            # await event.respond(translated)
            
        except Exception as e:
            print(f"Error in translate_and_send: {e}")
    
    def get_stats_text(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        last_trans = self.stats['last_translation']
        last_time = last_trans.strftime("%H:%M:%S") if last_trans else "–Ω–∏–∫–æ–≥–¥–∞"
        
        return (
            f"üìà **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–æ–≤:**\n"
            f"‚Ä¢ –í—Å–µ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–æ–≤: {self.stats['translations_done']}\n"
            f"‚Ä¢ –°–∏–º–≤–æ–ª–æ–≤ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ: {self.stats['characters_translated']:,}\n"
            f"‚Ä¢ –ü–æ–ø–∞–¥–∞–Ω–∏–π –≤ –∫—ç—à: {self.stats['cache_hits']}\n"
            f"‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø–µ—Ä–µ–≤–æ–¥: {last_time}\n"
            f"‚Ä¢ –†–∞–∑–º–µ—Ä –∫—ç—à–∞: {len(self.translation_cache)}"
        )
    
    def get_help_text(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –ø–æ–º–æ—â–∏"""
        return (
            "**ü§ñ DeepL –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ –¥–ª—è Telegram**\n\n"
            "**–ö–æ–º–∞–Ω–¥—ã:**\n"
            "‚Ä¢ –ü—Ä–æ—Å—Ç–æ –ø–∏—à–∏—Ç–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–≤–µ–¥–µ—Ç –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π\n"
            "‚Ä¢ `!translate [—Ç–µ–∫—Å—Ç]` - —Ä—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥\n"
            "‚Ä¢ `!translator on/off` - –≤–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ-–ø–µ—Ä–µ–≤–æ–¥\n"
            "‚Ä¢ `!translator status` - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n\n"
            "**–ù–∞—Å—Ç—Ä–æ–π–∫–∏ (–∏–∑–º–µ–Ω–∏—Ç–µ –≤ –∫–æ–¥–µ):**\n"
            "‚Ä¢ auto_translate: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥\n"
            "‚Ä¢ target_language: –Ø–∑—ã–∫ –ø–µ—Ä–µ–≤–æ–¥–∞ (EN, DE, FR, etc.)\n"
            "‚Ä¢ show_original: –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç\n"
            "‚Ä¢ cache_enabled: –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–æ–≤\n"
            "‚Ä¢ max_text_length: –ú–∞–∫—Å. –¥–ª–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞ (4000 —Å–∏–º–≤–æ–ª–æ–≤)"
        )

# ==================== –ò–ù–°–¢–†–£–ö–¶–ò–Ø –ü–û –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Æ ====================

"""
–£–°–¢–ê–ù–û–í–ö–ê –ù–ê HEROKU:

1. –ü–æ–ª—É—á–∏—Ç–µ DeepL API –∫–ª—é—á: https://www.deepl.com/pro-api

2. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫–ª—é—á –≤ Heroku:
   heroku config:set DEEPL_API_KEY="–≤–∞—à_–∫–ª—é—á_—Ç—É—Ç" -a –≤–∞—à–µ-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ

3. –î–æ–±–∞–≤—å—Ç–µ –ø–ª–∞–≥–∏–Ω –≤ main.py:

from deepl_translator import SafeDeepLTranslator

async def main():
    client = TelegramClient(...)
    await client.start()
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞
    translator = SafeDeepLTranslator(client)
    
    print("ü§ñ –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ DeepL –∑–∞–ø—É—â–µ–Ω!")
    await client.run_until_disconnected()

4. –¢—Ä–µ–±—É–µ–º—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ (requirements.txt):
   telethon>=1.24.0
   aiohttp>=3.8.0

5. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É !translator status –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
6. –ù–∞–ø–∏—à–∏—Ç–µ —á—Ç–æ-—Ç–æ –Ω–∞ —Ä—É—Å—Å–∫–æ–º - –ø–æ–ª—É—á–∏—Ç–µ –ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π!

–†–ê–ë–û–ß–ò–ï –Ø–ó–´–ö–ò DEEPL:
RU -> EN, DE, FR, ES, PT, IT, NL, PL, JA, ZH, etc.

–ë–ï–°–ü–õ–ê–¢–ù–´–ô –õ–ò–ú–ò–¢:
500,000 —Å–∏–º–≤–æ–ª–æ–≤ –≤ –º–µ—Å—è—Ü (Free –ø–ª–∞–Ω)
"""

# –¢–µ—Å—Ç–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
async def test_translation():
    """–¢–µ—Å—Ç–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏"""
    
    # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Å–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ
    TEST_API_KEY = os.getenv('DEEPL_API_KEY')
    
    if not TEST_API_KEY:
        print("‚ùå –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ DEEPL_API_KEY –¥–ª—è —Ç–µ—Å—Ç–∞")
        return
    
    # –ò–º–∏—Ç–∞—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥–∞
    test_text = "–ü—Ä–∏–≤–µ—Ç, –∫–∞–∫ –¥–µ–ª–∞? –°–µ–≥–æ–¥–Ω—è –æ—Ç–ª–∏—á–Ω–∞—è –ø–æ–≥–æ–¥–∞!"
    
    translator = SafeDeepLTranslator(None)  # None –≤–º–µ—Å—Ç–æ client –¥–ª—è —Ç–µ—Å—Ç–∞
    translator.api_key = TEST_API_KEY
    
    translated = await translator.translate_text(test_text)
    
    if translated:
        print(f"‚úÖ –¢–µ—Å—Ç –ø—Ä–æ–π–¥–µ–Ω!")
        print(f"–û—Ä–∏–≥–∏–Ω–∞–ª: {test_text}")
        print(f"–ü–µ—Ä–µ–≤–æ–¥: {translated}")
    else:
        print("‚ùå –¢–µ—Å—Ç –Ω–µ –ø—Ä–æ–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ API –∫–ª—é—á")

if __name__ == "__main__":
    # –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∞ –µ—Å–ª–∏ —Ñ–∞–π–ª –∑–∞–ø—É—â–µ–Ω –Ω–∞–ø—Ä—è–º—É—é
    asyncio.run(test_translation())
