#!/usr/bin/env python3
"""
Gemini Translator –¥–ª—è Telegram
–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ —Ä—É—Å—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π —á–µ—Ä–µ–∑ Google Gemini API
"""

import os
import asyncio
import hashlib
import json
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, List
import aiohttp
from telethon import TelegramClient, events
from telethon.tl import types
import logging

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class GeminiTranslator:
    """
    –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ –Ω–∞ –æ—Å–Ω–æ–≤–µ Google Gemini AI
    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø–µ—Ä–µ–≤–æ–¥, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞, –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–µ –ø–µ—Ä–µ–≤–æ–¥—ã
    """
    
    def __init__(self, client: TelegramClient, gemini_api_key: Optional[str] = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞
        
        Args:
            client: Telethon –∫–ª–∏–µ–Ω—Ç
            gemini_api_key: –ö–ª—é—á API Google Gemini (–∏–ª–∏ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è)
        """
        self.client = client
        self.api_key = gemini_api_key or os.getenv('GEMINI_API_KEY')
        
        if not self.api_key:
            logger.error("GEMINI_API_KEY –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è!")
            raise ValueError(
                "GEMINI_API_KEY –Ω–µ —É–∫–∞–∑–∞–Ω. "
                "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: export GEMINI_API_KEY='–≤–∞—à_–∫–ª—é—á' "
                "–∏–ª–∏ –≤ .env —Ñ–∞–π–ª–µ"
            )
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª—é—á
        self.validate_api_key()
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        self.settings = {
            'auto_translate': True,
            'target_language': '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π',
            'source_language': '—Ä—É—Å—Å–∫–∏–π',
            'show_original': True,
            'show_transliteration': False,  # –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—é
            'context_aware': True,  # –£—á–∏—Ç—ã–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç
            'formal_tone': False,  # –§–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω –ø–µ—Ä–µ–≤–æ–¥–∞
            'preserve_formatting': True,
            'max_length': 4000,
            'cache_enabled': True,
            'cache_size': 1000,
            'rate_limit': 15,  # –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –º–∏–Ω—É—Ç—É
            'ignore_commands': True,
            'ignore_links': False,
            'smart_language_detection': True,
            'reply_in_thread': False,  # –û—Ç–≤–µ—Ç –≤ —Ç—Ä–µ–¥–µ
        }
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        self.base_url = "https://generativelanguage.googleapis.com/v1beta/models"
        self.model = "gemini-pro"  # –∏–ª–∏ "gemini-pro-vision" –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
        
        # –ö—ç—à –ø–µ—Ä–µ–≤–æ–¥–æ–≤
        self.translation_cache: Dict[str, str] = {}
        self.language_cache: Dict[str, str] = {}
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = {
            'total_translations': 0,
            'total_characters': 0,
            'cache_hits': 0,
            'api_calls': 0,
            'errors': 0,
            'start_time': datetime.now(),
            'last_translation': None,
        }
        
        # –ò—Å—Ç–æ—Ä–∏—è –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞
        self.conversation_history: Dict[int, List[Dict]] = {}
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
        self.setup_handlers()
        
        logger.info(f"Gemini Translator –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω. –ú–æ–¥–µ–ª—å: {self.model}")
    
    def validate_api_key(self) -> bool:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è API –∫–ª—é—á–∞"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç –∫–ª—é—á–∞ Gemini
            if not self.api_key.startswith('AIza'):
                logger.warning("–ö–ª—é—á API –Ω–µ –ø–æ—Ö–æ–∂ –Ω–∞ –≤–∞–ª–∏–¥–Ω—ã–π Gemini –∫–ª—é—á")
                return False
            
            # –ú–∞—Å–∫–∏—Ä—É–µ–º –∫–ª—é—á –¥–ª—è –ª–æ–≥–æ–≤
            masked_key = self.api_key[:8] + '...' + self.api_key[-4:] if len(self.api_key) > 12 else '***'
            logger.info(f"Gemini API –∫–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω: {masked_key}")
            return True
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ API –∫–ª—é—á–∞: {e}")
            return False
    
    def setup_handlers(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π Telegram"""
        
        # –û—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        @self.client.on(events.NewMessage(outgoing=True))
        async def outgoing_message_handler(event):
            """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
            if not self.settings['auto_translate']:
                return
            
            message_text = event.message.message
            if not message_text or len(message_text.strip()) == 0:
                return
            
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ
            if self.settings['ignore_commands'] and message_text.startswith(('/', '!', '.')):
                return
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–∑—ã–∫
            if self.should_translate(message_text):
                await self.handle_translation(event, message_text)
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ —Ä—É—Å—Å–∫–∏–π)
        @self.client.on(events.NewMessage(incoming=True))
        async def incoming_message_handler(event):
            """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)"""
            if event.is_private:  # –¢–æ–ª—å–∫–æ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
                message_text = event.message.message
                if message_text and self.is_english_text(message_text):
                    # –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ —Ä—É—Å—Å–∫–∏–π
                    pass
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞
        @self.client.on(events.NewMessage(pattern=r'^!tr(?:anslate)?\s+(.+)$', outgoing=True))
        async def manual_translate_handler(event):
            """–†—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥ –ø–æ –∫–æ–º–∞–Ω–¥–µ !tr –∏–ª–∏ !translate"""
            text_to_translate = event.pattern_match.group(1).strip()
            if text_to_translate:
                await self.manual_translation(event, text_to_translate)
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫
        @self.client.on(events.NewMessage(pattern=r'^!transsettings\s*(.+)?$', outgoing=True))
        async def settings_handler(event):
            """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞"""
            args = event.pattern_match.group(1)
            await self.handle_settings(event, args)
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        @self.client.on(events.NewMessage(pattern='^!trstats$', outgoing=True))
        async def stats_handler(event):
            """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
            await self.show_stats(event)
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø–æ–º–æ—â–∏
        @self.client.on(events.NewMessage(pattern='^!trhelp$', outgoing=True))
        async def help_handler(event):
            """–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–º–æ—â—å"""
            await self.show_help(event)
        
        logger.info("–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã")
    
    def should_translate(self, text: str) -> bool:
        """
        –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å —Ç–µ–∫—Å—Ç
        
        Args:
            text: –¢–µ–∫—Å—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        
        Returns:
            bool: True –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å
        """
        if not text or len(text.strip()) < 2:
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —è–∑—ã–∫–∞
        text_hash = hashlib.md5(text.encode()).hexdigest()
        if text_hash in self.language_cache:
            return self.language_cache[text_hash] == 'ru'
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–∑—ã–∫
        detected_lang = self.detect_language_simple(text)
        self.language_cache[text_hash] = detected_lang
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∫—ç—à–∞
        if len(self.language_cache) > 500:
            self.language_cache.pop(next(iter(self.language_cache)))
        
        return detected_lang == 'ru'
    
    def detect_language_simple(self, text: str) -> str:
        """
        –ü—Ä–æ—Å—Ç–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞ (—Ä—É—Å—Å–∫–∏–π/–∞–Ω–≥–ª–∏–π—Å–∫–∏–π/–¥—Ä—É–≥–æ–π)
        
        Args:
            text: –¢–µ–∫—Å—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
        
        Returns:
            str: 'ru', 'en' –∏–ª–∏ 'other'
        """
        # –°—á–∏—Ç–∞–µ–º —Ä—É—Å—Å–∫–∏–µ –∏ –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ —Å–∏–º–≤–æ–ª—ã
        ru_count = 0
        en_count = 0
        total_alpha = 0
        
        for char in text.lower():
            if '–∞' <= char <= '—è' or char == '—ë':
                ru_count += 1
                total_alpha += 1
            elif 'a' <= char <= 'z':
                en_count += 1
                total_alpha += 1
        
        if total_alpha == 0:
            return 'other'
        
        ru_ratio = ru_count / total_alpha
        en_ratio = en_count / total_alpha
        
        if ru_ratio > 0.6:
            return 'ru'
        elif en_ratio > 0.6:
            return 'en'
        else:
            return 'other'
    
    def is_english_text(self, text: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç –∞–Ω–≥–ª–∏–π—Å–∫–∏–º"""
        return self.detect_language_simple(text) == 'en'
    
    def get_cache_key(self, text: str, context: str = "") -> str:
        """–°–æ–∑–¥–∞–µ—Ç –∫–ª—é—á –¥–ª—è –∫—ç—à–∞ –ø–µ—Ä–µ–≤–æ–¥–æ–≤"""
        key_string = f"{text}_{self.settings['target_language']}_{context}_{self.settings['formal_tone']}"
        return hashlib.md5(key_string.encode()).hexdigest()
    
    async def call_gemini_api(self, prompt: str, context: str = "") -> Optional[str]:
        """
        –í—ã–∑–æ–≤ Google Gemini API
        
        Args:
            prompt: –¢–µ–∫—Å—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç –ø–µ—Ä–µ–≤–æ–¥–∞
        
        Returns:
            str: –û—Ç–≤–µ—Ç –æ—Ç Gemini –∏–ª–∏ None –ø—Ä–∏ –æ—à–∏–±–∫–µ
        """
        self.stats['api_calls'] += 1
        
        url = f"{self.base_url}/{self.model}:generateContent?key={self.api_key}"
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å
        full_prompt = self.build_prompt(prompt, context)
        
        headers = {
            "Content-Type": "application/json",
        }
        
        payload = {
            "contents": [
                {
                    "parts": [
                        {"text": full_prompt}
                    ]
                }
            ],
            "generationConfig": {
                "temperature": 0.2,  # –ù–∏–∑–∫–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞
                "topK": 1,
                "topP": 0.95,
                "maxOutputTokens": 2048,
            },
            "safetySettings": [
                {
                    "category": "HARM_CATEGORY_HARASSMENT",
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_HATE_SPEECH", 
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                    "threshold": "BLOCK_NONE"
                }
            ]
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, headers=headers, json=payload, timeout=30) as response:
                    
                    if response.status == 200:
                        data = await response.json()
                        
                        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞
                        if 'candidates' in data and len(data['candidates']) > 0:
                            candidate = data['candidates'][0]
                            if 'content' in candidate and 'parts' in candidate['content']:
                                if len(candidate['content']['parts']) > 0:
                                    translated_text = candidate['content']['parts'][0]['text']
                                    
                                    # –û—á–∏—â–∞–µ–º –æ—Ç–≤–µ—Ç –æ—Ç –º–µ—Ç–∞-–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
                                    cleaned_text = self.clean_gemini_response(translated_text)
                                    return cleaned_text
                    
                    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
                    error_text = await response.text()
                    logger.error(f"Gemini API Error {response.status}: {error_text}")
                    
                    # –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ –∫–≤–æ—Ç—ã, –ø—Ä–æ–±—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥
                    if response.status == 429:
                        return await self.fallback_translation(prompt)
                    
                    return None
                    
        except asyncio.TimeoutError:
            logger.error("Gemini API timeout")
            return None
        except Exception as e:
            logger.error(f"Gemini API exception: {e}")
            self.stats['errors'] += 1
            return None
    
    def build_prompt(self, text: str, context: str = "") -> str:
        """
        –°—Ç—Ä–æ–∏—Ç –ø—Ä–æ–º–ø—Ç –¥–ª—è Gemini API
        
        Args:
            text: –¢–µ–∫—Å—Ç –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç
            
        Returns:
            str: –ü–æ–ª–Ω—ã–π –ø—Ä–æ–º–ø—Ç
        """
        tone = "—Ñ–æ—Ä–º–∞–ª—å–Ω–æ–º" if self.settings['formal_tone'] else "–µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–º"
        
        prompt_parts = [
            "–¢—ã –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ —Å —Ä—É—Å—Å–∫–æ–≥–æ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π.",
            f"–ü–µ—Ä–µ–≤–µ–¥–∏ —Å–ª–µ–¥—É—é—â–∏–π —Ç–µ–∫—Å—Ç —Å —Ä—É—Å—Å–∫–æ–≥–æ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –≤ {tone} —Å—Ç–∏–ª–µ:",
            "",
            f"–¢–ï–ö–°–¢ –î–õ–Ø –ü–ï–†–ï–í–û–î–ê:",
            f"```",
            f"{text}",
            f"```",
        ]
        
        if context and self.settings['context_aware']:
            prompt_parts.extend([
                "",
                "–ö–û–ù–¢–ï–ö–°–¢:",
                f"{context}",
                "",
                "–£—á—Ç–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–∏ –ø–µ—Ä–µ–≤–æ–¥–µ."
            ])
        
        prompt_parts.extend([
            "",
            "–ü–†–ê–í–ò–õ–ê –ü–ï–†–ï–í–û–î–ê:",
            "1. –°–æ—Ö—Ä–∞–Ω—è–π –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Å–º—ã—Å–ª",
            "2. –ò—Å–ø–æ–ª—å–∑—É–π –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –∞–Ω–≥–ª–∏–π—Å–∫–∏–π —è–∑—ã–∫",
            "3. –°–æ—Ö—Ä–∞–Ω—è–π —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å",
            "4. –ù–µ –¥–æ–±–∞–≤–ª—è–π –ø–æ—è—Å–Ω–µ–Ω–∏—è",
            "5. –ù–µ –ø–µ—Ä–µ–≤–æ–¥–∏ –∏–º–µ–Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ",
            "6. –ù–µ –ø–µ—Ä–µ–≤–æ–¥–∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ç–µ—Ä–º–∏–Ω—ã –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏",
            "",
            "–û–¢–í–ï–¢ –î–û–õ–ñ–ï–ù –°–û–î–ï–†–ñ–ê–¢–¨ –¢–û–õ–¨–ö–û –ü–ï–†–ï–í–û–î:"
        ])
        
        return "\n".join(prompt_parts)
    
    def clean_gemini_response(self, text: str) -> str:
        """–û—á–∏—â–∞–µ—Ç –æ—Ç–≤–µ—Ç –æ—Ç Gemini –æ—Ç –ª–∏—à–Ω–µ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"""
        # –£–±–∏—Ä–∞–µ–º –∫–∞–≤—ã—á–∫–∏ –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç –æ–±–µ—Ä–Ω—É—Ç –≤ –Ω–∏—Ö
        if text.startswith('"') and text.endswith('"'):
            text = text[1:-1]
        
        # –£–±–∏—Ä–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ/–∫–æ–Ω–µ—á–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã
        text = text.strip()
        
        # –£–±–∏—Ä–∞–µ–º –º–µ—Ç–∫–∏ –ø–µ—Ä–µ–≤–æ–¥–∞ –µ—Å–ª–∏ –µ—Å—Ç—å
        text = text.replace("–ü–µ—Ä–µ–≤–æ–¥:", "").replace("Translation:", "").strip()
        
        return text
    
    async def fallback_translation(self, text: str) -> Optional[str]:
        """
        –ó–∞–ø–∞—Å–Ω–æ–π –º–µ—Ç–æ–¥ –ø–µ—Ä–µ–≤–æ–¥–∞ –µ—Å–ª–∏ Gemini –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –ø—Ä–æ—Å—Ç—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –∏–ª–∏ –¥—Ä—É–≥–∏–µ API
        """
        logger.info("–ò—Å–ø–æ–ª—å–∑—É—é fallback –ø–µ—Ä–µ–≤–æ–¥")
        
        # –ü—Ä–æ—Å—Ç–æ–π —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Ñ—Ä–∞–∑
        common_phrases = {
            "–ø—Ä–∏–≤–µ—Ç": "hello",
            "–∫–∞–∫ –¥–µ–ª–∞": "how are you",
            "—Å–ø–∞—Å–∏–±–æ": "thank you",
            "–ø–æ–∂–∞–ª—É–π—Å—Ç–∞": "you're welcome",
            "–∏–∑–≤–∏–Ω–∏—Ç–µ": "sorry",
            "–¥–∞": "yes",
            "–Ω–µ—Ç": "no",
            "—Ö–æ—Ä–æ—à–æ": "good",
            "–ø–ª–æ—Ö–æ": "bad",
            "—á—Ç–æ –¥–µ–ª–∞–µ—à—å": "what are you doing",
        }
        
        text_lower = text.lower()
        for ru, en in common_phrases.items():
            if ru in text_lower:
                return en
        
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º None
        return None
    
    async def handle_translation(self, event, original_text: str):
        """
        –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏—è
        
        Args:
            event: –°–æ–±—ã—Ç–∏–µ Telegram
            original_text: –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
            context = ""
            if self.settings['context_aware'] and event.chat_id in self.conversation_history:
                # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 —Å–æ–æ–±—â–µ–Ω–∏–π –∫–∞–∫ –∫–æ–Ω—Ç–µ–∫—Å—Ç
                recent_messages = self.conversation_history[event.chat_id][-5:]
                context = " | ".join([msg['text'] for msg in recent_messages])
            
            # –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥
            translated = await self.get_translation(original_text, context)
            
            if not translated:
                return
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é
            if event.chat_id not in self.conversation_history:
                self.conversation_history[event.chat_id] = []
            
            self.conversation_history[event.chat_id].append({
                'text': original_text,
                'translated': translated,
                'time': datetime.now()
            })
            
            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏
            if len(self.conversation_history[event.chat_id]) > 20:
                self.conversation_history[event.chat_id].pop(0)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
            await self.send_translation_response(event, original_text, translated)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            self.stats['total_translations'] += 1
            self.stats['total_characters'] += len(original_text)
            self.stats['last_translation'] = datetime.now()
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–µ—Ä–µ–≤–æ–¥–∞: {e}")
            self.stats['errors'] += 1
    
    async def get_translation(self, text: str, context: str = "") -> Optional[str]:
        """
        –ü–æ–ª—É—á–∞–µ—Ç –ø–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
        
        Args:
            text: –¢–µ–∫—Å—Ç –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç
            
        Returns:
            str: –ü–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –∏–ª–∏ None
        """
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª–∏–Ω—É
        if len(text) > self.settings['max_length']:
            text = text[:self.settings['max_length']] + "..."
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        cache_key = self.get_cache_key(text, context)
        if self.settings['cache_enabled'] and cache_key in self.translation_cache:
            self.stats['cache_hits'] += 1
            return self.translation_cache[cache_key]
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥ –æ—Ç Gemini
        translated = await self.call_gemini_api(text, context)
        
        if translated and self.settings['cache_enabled']:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
            self.translation_cache[cache_key] = translated
            
            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∫—ç—à–∞
            if len(self.translation_cache) > self.settings['cache_size']:
                self.translation_cache.pop(next(iter(self.translation_cache)))
        
        return translated
    
    async def send_translation_response(self, event, original_text: str, translated_text: str):
        """
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ —á–∞—Ç
        
        Args:
            event: –°–æ–±—ã—Ç–∏–µ Telegram
            original_text: –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç
            translated_text: –ü–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
        """
        try:
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
            response_parts = []
            
            if self.settings['show_original']:
                response_parts.append(f"üá∑üá∫ **–û—Ä–∏–≥–∏–Ω–∞–ª:**\n{original_text}")
            
            response_parts.append(f"üá∫üá∏ **–ü–µ—Ä–µ–≤–æ–¥:**\n{translated_text}")
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—é –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            if self.settings['show_transliteration']:
                translit = self.transliterate_russian(original_text)
                response_parts.append(f"üî§ **–¢—Ä–∞–Ω—Å–ª–∏—Ç:**\n{translit}")
            
            response_parts.append("_‚ú® –ü–µ—Ä–µ–≤–µ–¥–µ–Ω–æ —á–µ—Ä–µ–∑ Google Gemini AI_")
            
            response = "\n\n".join(response_parts)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
            if self.settings['reply_in_thread'] and event.is_reply:
                # –í —Ç—Ä–µ–¥–µ –µ—Å–ª–∏ —ç—Ç–æ –æ—Ç–≤–µ—Ç
                await event.reply(response, parse_mode='md')
            else:
                # –ö–∞–∫ –æ—Ç–¥–µ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                await event.respond(response, parse_mode='md')
            
            # –ú–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            # await event.delete()
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞: {e}")
    
    def transliterate_russian(self, text: str) -> str:
        """
        –ü—Ä–æ—Å—Ç–∞—è —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è —Ä—É—Å—Å–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
        
        Args:
            text: –†—É—Å—Å–∫–∏–π —Ç–µ–∫—Å—Ç
            
        Returns:
            str: –¢—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
        """
        translit_dict = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd',
            '–µ': 'e', '—ë': 'yo', '–∂': 'zh', '–∑': 'z', '–∏': 'i',
            '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm', '–Ω': 'n',
            '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't',
            '—É': 'u', '—Ñ': 'f', '—Ö': 'kh', '—Ü': 'ts', '—á': 'ch',
            '—à': 'sh', '—â': 'shch', '—ä': '', '—ã': 'y', '—å': '',
            '—ç': 'e', '—é': 'yu', '—è': 'ya',
            '–ê': 'A', '–ë': 'B', '–í': 'V', '–ì': 'G', '–î': 'D',
            '–ï': 'E', '–Å': 'Yo', '–ñ': 'Zh', '–ó': 'Z', '–ò': 'I',
            '–ô': 'Y', '–ö': 'K', '–õ': 'L', '–ú': 'M', '–ù': 'N',
            '–û': 'O', '–ü': 'P', '–†': 'R', '–°': 'S', '–¢': 'T',
            '–£': 'U', '–§': 'F', '–•': 'Kh', '–¶': 'Ts', '–ß': 'Ch',
            '–®': 'Sh', '–©': 'Shch', '–™': '', '–´': 'Y', '–¨': '',
            '–≠': 'E', '–Æ': 'Yu', '–Ø': 'Ya',
        }
        
        result = []
        for char in text:
            if char in translit_dict:
                result.append(translit_dict[char])
            else:
                result.append(char)
        
        return ''.join(result)
    
    async def manual_translation(self, event, text: str):
        """–†—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥ –ø–æ –∫–æ–º–∞–Ω–¥–µ"""
        try:
            translated = await self.get_translation(text)
            
            if translated:
                await event.reply(
                    f"**üìù –†—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥:**\n\n"
                    f"üá∑üá∫ **–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç:**\n{text}\n\n"
                    f"üá∫üá∏ **–ü–µ—Ä–µ–≤–æ–¥:**\n{translated}\n\n"
                    f"_‚ú® Google Gemini AI_",
                    parse_mode='md'
                )
            else:
                await event.reply("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ API –∫–ª—é—á.")
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Ä—É—á–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞: {e}")
            await event.reply(f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: {str(e)}")
    
    async def handle_settings(self, event, args: Optional[str]):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ –Ω–∞—Å—Ç—Ä–æ–µ–∫"""
        if not args:
            # –ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
            settings_text = self.format_settings()
            await event.reply(settings_text, parse_mode='md')
            return
        
        args = args.strip().lower()
        
        if args == "on":
            self.settings['auto_translate'] = True
            await event.reply("‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ –≤–∫–ª—é—á–µ–Ω")
        
        elif args == "off":
            self.settings['auto_translate'] = False
            await event.reply("‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ –≤—ã–∫–ª—é—á–µ–Ω")
        
        elif args.startswith("lang "):
            lang = args.split(" ", 1)[1]
            if lang in ['en', 'english', '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π']:
                self.settings['target_language'] = '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π'
                await event.reply("‚úÖ –¶–µ–ª–µ–≤–æ–π —è–∑—ã–∫: –ê–Ω–≥–ª–∏–π—Å–∫–∏–π")
            elif lang in ['ru', 'russian', '—Ä—É—Å—Å–∫–∏–π']:
                self.settings['target_language'] = '—Ä—É—Å—Å–∫–∏–π'
                await event.reply("‚úÖ –¶–µ–ª–µ–≤–æ–π —è–∑—ã–∫: –†—É—Å—Å–∫–∏–π")
            else:
                await event.reply("‚ùå –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ: en/english –∏–ª–∏ ru/russian")
        
        elif args == "formal on":
            self.settings['formal_tone'] = True
            await event.reply("‚úÖ –§–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω –ø–µ—Ä–µ–≤–æ–¥–∞ –≤–∫–ª—é—á–µ–Ω")
        
        elif args == "formal off":
            self.settings['formal_tone'] = False
            await event.reply("‚úÖ –§–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω –ø–µ—Ä–µ–≤–æ–¥–∞ –≤—ã–∫–ª—é—á–µ–Ω")
        
        elif args == "context on":
            self.settings['context_aware'] = True
            await event.reply("‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –≤–∫–ª—é—á–µ–Ω")
        
        elif args == "context off":
            self.settings['context_aware'] = False
            await event.reply("‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –≤—ã–∫–ª—é—á–µ–Ω")
        
        elif args == "help":
            await self.show_help(event)
        
        else:
            await event.reply(
                "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ:\n"
                "‚Ä¢ `!transsettings` - –ø–æ–∫–∞–∑–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n"
                "‚Ä¢ `!transsettings on/off` - –≤–∫–ª/–≤—ã–∫–ª –∞–≤—Ç–æ-–ø–µ—Ä–µ–≤–æ–¥\n"
                "‚Ä¢ `!transsettings lang en/ru` - –∏–∑–º–µ–Ω–∏—Ç—å —è–∑—ã–∫\n"
                "‚Ä¢ `!transsettings formal on/off` - —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω\n"
                "‚Ä¢ `!transsettings context on/off` - –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥\n"
                "‚Ä¢ `!transsettings help` - –ø–æ–º–æ—â—å"
            )
    
    def format_settings(self) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
        settings_list = []
        for key, value in self.settings.items():
            if isinstance(value, bool):
                value_str = "‚úÖ –í–ö–õ" if value else "‚ùå –í–´–ö–õ"
            else:
                value_str = str(value)
            settings_list.append(f"**{key}:** {value_str}")
        
        return "**‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞:**\n\n" + "\n".join(settings_list)
    
    async def show_stats(self, event):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
        uptime = datetime.now() - self.stats['start_time']
        hours, remainder = divmod(uptime.total_seconds(), 3600)
        minutes, seconds = divmod(remainder, 60)
        
        last_trans = self.stats['last_translation']
        last_time = last_trans.strftime("%H:%M:%S") if last_trans else "–Ω–∏–∫–æ–≥–¥–∞"
        
        stats_text = (
            f"**üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞:**\n\n"
            f"‚Ä¢ –í—Å–µ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–æ–≤: **{self.stats['total_translations']}**\n"
            f"‚Ä¢ –°–∏–º–≤–æ–ª–æ–≤ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ: **{self.stats['total_characters']:,}**\n"
            f"‚Ä¢ –ó–∞–ø—Ä–æ—Å–æ–≤ –∫ API: **{self.stats['api_calls']}**\n"
            f"‚Ä¢ –ü–æ–ø–∞–¥–∞–Ω–∏–π –≤ –∫—ç—à: **{self.stats['cache_hits']}**\n"
            f"‚Ä¢ –û—à–∏–±–æ–∫: **{self.stats['errors']}**\n"
            f"‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø–µ—Ä–µ–≤–æ–¥: **{last_time}**\n"
            f"‚Ä¢ –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: **{int(hours)}—á {int(minutes)}–º {int(seconds)}—Å**\n"
            f"‚Ä¢ –†–∞–∑–º–µ—Ä –∫—ç—à–∞: **{len(self.translation_cache)}/{self.settings['cache_size']}**\n"
            f"‚Ä¢ –ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–æ–≤: **{len(self.conversation_history)}**"
        )
        
        await event.reply(stats_text, parse_mode='md')
    
    async def show_help(self, event):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É"""
        help_text = (
            "**ü§ñ Gemini –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ –¥–ª—è Telegram**\n\n"
            "**–û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:**\n"
            "‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ —Ä—É—Å—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π\n"
            "‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞\n"
            "‚Ä¢ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤\n"
            "‚Ä¢ –§–æ—Ä–º–∞–ª—å–Ω—ã–π/–Ω–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω\n"
            "‚Ä¢ –¢—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è\n\n"
            "**–ö–æ–º–∞–Ω–¥—ã:**\n"
            "‚Ä¢ –ü—Ä–æ—Å—Ç–æ –ø–∏—à–∏—Ç–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥\n"
            "‚Ä¢ `!tr [—Ç–µ–∫—Å—Ç]` - —Ä—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥\n"
            "‚Ä¢ `!translate [—Ç–µ–∫—Å—Ç]` - —Ä—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥ (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞)\n"
            "‚Ä¢ `!transsettings` - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n"
            "‚Ä¢ `!trstats` - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n"
            "‚Ä¢ `!trhelp` - —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n\n"
            "**–ù–∞—Å—Ç—Ä–æ–π–∫–∏ (—á–µ—Ä–µ–∑ !transsettings):**\n"
            "‚Ä¢ `on/off` - –≤–∫–ª/–≤—ã–∫–ª –∞–≤—Ç–æ-–ø–µ—Ä–µ–≤–æ–¥\n"
            "‚Ä¢ `lang en/ru` - —Ü–µ–ª–µ–≤–æ–π —è–∑—ã–∫\n"
            "‚Ä¢ `formal on/off` - —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω\n"
            "‚Ä¢ `context on/off` - –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥\n\n"
            "**–ò—Å–ø–æ–ª—å–∑—É–µ—Ç:** Google Gemini Pro AI\n"
            f"**–ú–æ–¥–µ–ª—å:** {self.model}\n"
            "**–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫:** Telegram AI Assistant"
        )
        
        await event.reply(help_text, parse_mode='md')


# ==================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò –ó–ê–ü–£–°–ö ====================

import configparser

def load_config(config_file: str = 'config.ini') -> dict:
    """–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ —Ñ–∞–π–ª–∞"""
    config = configparser.ConfigParser()
    
    if os.path.exists(config_file):
        config.read(config_file)
    else:
        # –°–æ–∑–¥–∞–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–π –∫–æ–Ω—Ñ–∏–≥
        config['telegram'] = {
            'api_id': '–í–ê–®_API_ID',
            'api_hash': '–í–ê–®_API_HASH',
            'session_name': 'gemini_translator'
        }
        config['gemini'] = {
            'api_key': '–í–ê–®_GEMINI_API_KEY'
        }
        
        with open(config_file, 'w') as f:
            config.write(f)
        
        print(f"‚ö†Ô∏è –°–æ–∑–¥–∞–Ω –∫–æ–Ω—Ñ–∏–≥ —Ñ–∞–π–ª: {config_file}")
        print("‚ö†Ô∏è –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –µ–≥–æ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º!")
    
    return config

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞"""
    print("üöÄ –ó–∞–ø—É—Å–∫ Gemini Translator –¥–ª—è Telegram...")
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    config = load_config()
    
    # –ü–æ–ª—É—á–∞–µ–º —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    api_id = int(config['telegram']['api_id'])
    api_hash = config['telegram']['api_hash']
    session_name = config['telegram']['session_name']
    gemini_api_key = config['gemini']['api_key']
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    if api_id == '–í–ê–®_API_ID' or api_hash == '–í–ê–®_API_HASH':
        print("‚ùå –ó–∞–ø–æ–ª–Ω–∏—Ç–µ config.ini —Ñ–∞–π–ª —Å–≤–æ–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏!")
        return
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∏–µ–Ω—Ç Telegram
    client = TelegramClient(session_name, api_id, api_hash)
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫
    translator = GeminiTranslator(client, gemini_api_key)
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –∫–ª–∏–µ–Ω—Ç
    await client.start()
    
    print(f"‚úÖ Gemini Translator –∑–∞–ø—É—â–µ–Ω!")
    print(f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {await client.get_me()}")
    print(f"ü§ñ –ú–æ–¥–µ–ª—å AI: {translator.model}")
    print(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –ø–æ –∫–æ–º–∞–Ω–¥–µ: !trstats")
    print(f"üÜò –ü–æ–º–æ—â—å: !trhelp")
    print("\n–¢–µ–ø–µ—Ä—å –ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ —Ä—É—Å—Å–∫–æ–º - –æ–Ω–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–≤–µ–¥—É—Ç—Å—è!")
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª
    await client.run_until_disconnected()

if __name__ == '__main__':
    # –ó–∞–ø—É—Å–∫ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    asyncio.run(main())
