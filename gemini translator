#!/usr/bin/env python3
"""
Gemini Translator –¥–ª—è Telegram - Heroku —Å–æ–≤–º–µ—Å—Ç–∏–º–∞—è –≤–µ—Ä—Å–∏—è
–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ —Ä—É—Å—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π —á–µ—Ä–µ–∑ Google Gemini API
"""

import os
import asyncio
import hashlib
import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, List
import aiohttp
from telethon import TelegramClient, events
from telethon.tl import types
import logging

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è Heroku
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class GeminiTranslator:
    """
    –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ –Ω–∞ –æ—Å–Ω–æ–≤–µ Google Gemini AI
    Heroku-—Å–æ–≤–º–µ—Å—Ç–∏–º–∞—è –≤–µ—Ä—Å–∏—è —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º–∏
    """
    
    def __init__(self, client: TelegramClient, gemini_api_key: Optional[str] = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞ –¥–ª—è Heroku
        
        Args:
            client: Telethon –∫–ª–∏–µ–Ω—Ç
            gemini_api_key: –ö–ª—é—á API Google Gemini
        """
        self.client = client
        
        # –ü–æ–ª—É—á–∞–µ–º API –∫–ª—é—á –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è Heroku
        self.api_key = gemini_api_key or os.getenv('GEMINI_API_KEY')
        
        if not self.api_key:
            # –ü—Ä–æ–±—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∏–º–µ–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
            self.api_key = os.getenv('GOOGLE_AI_API_KEY') or os.getenv('GOOGLE_API_KEY')
        
        if not self.api_key:
            logger.error("GEMINI_API_KEY –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è!")
            logger.error("–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤ Heroku: GEMINI_API_KEY='–≤–∞—à_–∫–ª—é—á_–∑–¥–µ—Å—å'")
            raise ValueError(
                "GEMINI_API_KEY –Ω–µ —É–∫–∞–∑–∞–Ω. "
                "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ Heroku –∏–ª–∏ –≤ .env —Ñ–∞–π–ª–µ"
            )
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª—é—á
        self.validate_api_key()
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è Heroku
        self.settings = {
            'auto_translate': True,
            'target_language': '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π',
            'source_language': '—Ä—É—Å—Å–∫–∏–π',
            'show_original': True,
            'show_transliteration': False,
            'context_aware': True,
            'formal_tone': False,
            'preserve_formatting': True,
            'max_length': 4000,
            'cache_enabled': True,
            'cache_size': 500,  # –£–º–µ–Ω—å—à–µ–Ω–æ –¥–ª—è Heroku
            'rate_limit': 10,  # –£–º–µ–Ω—å—à–µ–Ω–æ –¥–ª—è Heroku
            'ignore_commands': True,
            'ignore_links': False,
            'smart_language_detection': True,
            'reply_in_thread': False,
            'use_web_preview': False,  # –û—Ç–∫–ª—é—á–µ–Ω–æ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
        }
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è API
        self.base_url = "https://generativelanguage.googleapis.com/v1beta/models"
        self.model = "gemini-1.5-pro-latest"  # –ê–∫—Ç—É–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å
        
        # –ö—ç—à –ø–µ—Ä–µ–≤–æ–¥–æ–≤
        self.translation_cache: Dict[str, str] = {}
        self.language_cache: Dict[str, str] = {}
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = {
            'total_translations': 0,
            'total_characters': 0,
            'cache_hits': 0,
            'api_calls': 0,
            'errors': 0,
            'start_time': datetime.now(),
            'last_translation': None,
        }
        
        # –ò—Å—Ç–æ—Ä–∏—è –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞
        self.conversation_history: Dict[int, List[Dict]] = {}
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
        self.setup_handlers()
        
        logger.info(f"Gemini Translator –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è Heroku. –ú–æ–¥–µ–ª—å: {self.model}")
    
    def validate_api_key(self) -> bool:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è API –∫–ª—é—á–∞"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç –∫–ª—é—á–∞ Gemini
            if not self.api_key.startswith('AIza'):
                logger.warning("–ö–ª—é—á API –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–º –¥–ª—è Gemini")
                # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ, —Ç–æ–ª—å–∫–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ–º
            
            # –ú–∞—Å–∫–∏—Ä—É–µ–º –∫–ª—é—á –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            masked_key = self.api_key[:8] + '...' + self.api_key[-4:] if len(self.api_key) > 12 else '***'
            logger.info(f"Gemini API –∫–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω: {masked_key}")
            return True
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ API –∫–ª—é—á–∞: {e}")
            return False
    
    def setup_handlers(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π Telegram"""
        
        # –û—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        @self.client.on(events.NewMessage(outgoing=True))
        async def outgoing_message_handler(event):
            """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
            if not self.settings['auto_translate']:
                return
            
            message_text = event.message.message
            if not message_text or len(message_text.strip()) == 0:
                return
            
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ
            if self.settings['ignore_commands'] and message_text.startswith(('/', '!', '.')):
                return
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–∑—ã–∫
            if self.should_translate(message_text):
                await self.handle_translation(event, message_text)
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        @self.client.on(events.NewMessage(incoming=True))
        async def incoming_message_handler(event):
            """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)"""
            if event.is_private:  # –¢–æ–ª—å–∫–æ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
                message_text = event.message.message
                if message_text and self.is_english_text(message_text):
                    # –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ —Ä—É—Å—Å–∫–∏–π
                    pass
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞
        @self.client.on(events.NewMessage(pattern=r'^!tr(?:anslate)?\s+(.+)$'))
        async def manual_translate_handler(event):
            """–†—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥ –ø–æ –∫–æ–º–∞–Ω–¥–µ"""
            text_to_translate = event.pattern_match.group(1).strip()
            if text_to_translate:
                await self.manual_translation(event, text_to_translate)
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫
        @self.client.on(events.NewMessage(pattern=r'^!transsettings\s*(.+)?$'))
        async def settings_handler(event):
            """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏"""
            args = event.pattern_match.group(1)
            await self.handle_settings(event, args)
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        @self.client.on(events.NewMessage(pattern='^!trstats$'))
        async def stats_handler(event):
            """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
            await self.show_stats(event)
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø–æ–º–æ—â–∏
        @self.client.on(events.NewMessage(pattern='^!trhelp$'))
        async def help_handler(event):
            """–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–º–æ—â—å"""
            await self.show_help(event)
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏
        @self.client.on(events.NewMessage(pattern='^!trreload$'))
        async def reload_handler(event):
            """–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞"""
            await event.reply("üîÑ –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞...")
            self.translation_cache.clear()
            self.language_cache.clear()
            await event.reply("‚úÖ –ö—ç—à –æ—á–∏—â–µ–Ω, –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω")
        
        logger.info("–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã")
    
    def should_translate(self, text: str) -> bool:
        """
        –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å —Ç–µ–∫—Å—Ç
        """
        if not text or len(text.strip()) < 2:
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        text_hash = hashlib.md5(text.encode()).hexdigest()
        if text_hash in self.language_cache:
            return self.language_cache[text_hash] == 'ru'
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–∑—ã–∫
        detected_lang = self.detect_language_simple(text)
        self.language_cache[text_hash] = detected_lang
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∫—ç—à–∞
        if len(self.language_cache) > 300:
            self.language_cache.pop(next(iter(self.language_cache)))
        
        return detected_lang == 'ru'
    
    def detect_language_simple(self, text: str) -> str:
        """
        –ü—Ä–æ—Å—Ç–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞
        """
        ru_count = 0
        en_count = 0
        total_alpha = 0
        
        for char in text.lower():
            if '–∞' <= char <= '—è' or char == '—ë':
                ru_count += 1
                total_alpha += 1
            elif 'a' <= char <= 'z':
                en_count += 1
                total_alpha += 1
        
        if total_alpha == 0:
            return 'other'
        
        ru_ratio = ru_count / total_alpha
        en_ratio = en_count / total_alpha
        
        if ru_ratio > 0.6:
            return 'ru'
        elif en_ratio > 0.6:
            return 'en'
        else:
            return 'other'
    
    def is_english_text(self, text: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç –∞–Ω–≥–ª–∏–π—Å–∫–∏–º"""
        return self.detect_language_simple(text) == 'en'
    
    def get_cache_key(self, text: str, context: str = "") -> str:
        """–°–æ–∑–¥–∞–µ—Ç –∫–ª—é—á –¥–ª—è –∫—ç—à–∞"""
        key_string = f"{text}_{self.settings['target_language']}_{context}_{self.settings['formal_tone']}"
        return hashlib.md5(key_string.encode()).hexdigest()
    
    async def call_gemini_api(self, prompt: str, context: str = "") -> Optional[str]:
        """
        –í—ã–∑–æ–≤ Google Gemini API —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫ –¥–ª—è Heroku
        """
        self.stats['api_calls'] += 1
        
        url = f"{self.base_url}/{self.model}:generateContent?key={self.api_key}"
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å
        full_prompt = self.build_prompt(prompt, context)
        
        headers = {
            "Content-Type": "application/json",
        }
        
        payload = {
            "contents": [
                {
                    "parts": [
                        {"text": full_prompt}
                    ]
                }
            ],
            "generationConfig": {
                "temperature": 0.2,
                "topK": 1,
                "topP": 0.95,
                "maxOutputTokens": 2048,
            },
            "safetySettings": [
                {
                    "category": "HARM_CATEGORY_HARASSMENT",
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_HATE_SPEECH", 
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                    "threshold": "BLOCK_NONE"
                }
            ]
        }
        
        try:
            timeout = aiohttp.ClientTimeout(total=45)
            async with aiohttp.ClientSession(timeout=timeout) as session:
                async with session.post(url, headers=headers, json=payload) as response:
                    
                    if response.status == 200:
                        data = await response.json()
                        
                        if 'candidates' in data and len(data['candidates']) > 0:
                            candidate = data['candidates'][0]
                            if 'content' in candidate and 'parts' in candidate['content']:
                                if len(candidate['content']['parts']) > 0:
                                    translated_text = candidate['content']['parts'][0]['text']
                                    cleaned_text = self.clean_gemini_response(translated_text)
                                    return cleaned_text
                    
                    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
                    error_text = await response.text()
                    logger.error(f"Gemini API Error {response.status}: {error_text[:200]}")
                    
                    if response.status == 429:
                        logger.warning("–î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤, –∂–¥–µ–º...")
                        await asyncio.sleep(10)
                        return await self.fallback_translation(prompt)
                    
                    return None
                    
        except asyncio.TimeoutError:
            logger.error("Gemini API timeout, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback")
            return await self.fallback_translation(prompt)
        except Exception as e:
            logger.error(f"Gemini API exception: {e}")
            self.stats['errors'] += 1
            return await self.fallback_translation(prompt)
    
    def build_prompt(self, text: str, context: str = "") -> str:
        """
        –°—Ç—Ä–æ–∏—Ç –ø—Ä–æ–º–ø—Ç –¥–ª—è Gemini API
        """
        tone = "—Ñ–æ—Ä–º–∞–ª—å–Ω–æ–º" if self.settings['formal_tone'] else "–µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–º"
        
        prompt_parts = [
            "–¢—ã –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ —Å —Ä—É—Å—Å–∫–æ–≥–æ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π.",
            f"–ü–µ—Ä–µ–≤–µ–¥–∏ —Å–ª–µ–¥—É—é—â–∏–π —Ç–µ–∫—Å—Ç —Å —Ä—É—Å—Å–∫–æ–≥–æ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –≤ {tone} —Å—Ç–∏–ª–µ:",
            "",
            f"–¢–ï–ö–°–¢ –î–õ–Ø –ü–ï–†–ï–í–û–î–ê:",
            f"```",
            f"{text}",
            f"```",
        ]
        
        if context and self.settings['context_aware']:
            prompt_parts.extend([
                "",
                "–ö–û–ù–¢–ï–ö–°–¢:",
                f"{context}",
                "",
                "–£—á—Ç–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–∏ –ø–µ—Ä–µ–≤–æ–¥–µ."
            ])
        
        prompt_parts.extend([
            "",
            "–ü–†–ê–í–ò–õ–ê –ü–ï–†–ï–í–û–î–ê:",
            "1. –°–æ—Ö—Ä–∞–Ω—è–π –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Å–º—ã—Å–ª",
            "2. –ò—Å–ø–æ–ª—å–∑—É–π –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –∞–Ω–≥–ª–∏–π—Å–∫–∏–π —è–∑—ã–∫",
            "3. –°–æ—Ö—Ä–∞–Ω—è–π —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å",
            "4. –ù–µ –¥–æ–±–∞–≤–ª—è–π –ø–æ—è—Å–Ω–µ–Ω–∏—è",
            "5. –ù–µ –ø–µ—Ä–µ–≤–æ–¥–∏ –∏–º–µ–Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ",
            "6. –ù–µ –ø–µ—Ä–µ–≤–æ–¥–∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ç–µ—Ä–º–∏–Ω—ã –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏",
            "",
            "–û–¢–í–ï–¢ –î–û–õ–ñ–ï–ù –°–û–î–ï–†–ñ–ê–¢–¨ –¢–û–õ–¨–ö–û –ü–ï–†–ï–í–û–î:"
        ])
        
        return "\n".join(prompt_parts)
    
    def clean_gemini_response(self, text: str) -> str:
        """–û—á–∏—â–∞–µ—Ç –æ—Ç–≤–µ—Ç –æ—Ç Gemini"""
        if text.startswith('"') and text.endswith('"'):
            text = text[1:-1]
        
        text = text.strip()
        
        text = text.replace("–ü–µ—Ä–µ–≤–æ–¥:", "").replace("Translation:", "").strip()
        
        return text
    
    async def fallback_translation(self, text: str) -> Optional[str]:
        """
        –ó–∞–ø–∞—Å–Ω–æ–π –º–µ—Ç–æ–¥ –ø–µ—Ä–µ–≤–æ–¥–∞
        """
        logger.info("–ò—Å–ø–æ–ª—å–∑—É—é fallback –ø–µ—Ä–µ–≤–æ–¥")
        
        # –ü—Ä–æ—Å—Ç–æ–π —Å–ª–æ–≤–∞—Ä—å
        common_phrases = {
            "–ø—Ä–∏–≤–µ—Ç": "hello",
            "–∫–∞–∫ –¥–µ–ª–∞": "how are you",
            "—Å–ø–∞—Å–∏–±–æ": "thank you",
            "–ø–æ–∂–∞–ª—É–π—Å—Ç–∞": "you're welcome",
            "–∏–∑–≤–∏–Ω–∏—Ç–µ": "sorry",
            "–¥–∞": "yes",
            "–Ω–µ—Ç": "no",
            "—Ö–æ—Ä–æ—à–æ": "good",
            "–ø–ª–æ—Ö–æ": "bad",
            "—á—Ç–æ –¥–µ–ª–∞–µ—à—å": "what are you doing",
        }
        
        text_lower = text.lower()
        for ru, en in common_phrases.items():
            if ru in text_lower:
                return en
        
        return "Sorry, translation service is temporarily unavailable."
    
    async def handle_translation(self, event, original_text: str):
        """
        –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏—è
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç
            context = ""
            if self.settings['context_aware'] and event.chat_id in self.conversation_history:
                recent_messages = self.conversation_history[event.chat_id][-3:]  # –£–º–µ–Ω—å—à–µ–Ω–æ –¥–ª—è Heroku
                context = " | ".join([msg['text'] for msg in recent_messages])
            
            # –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥
            translated = await self.get_translation(original_text, context)
            
            if not translated:
                return
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é
            if event.chat_id not in self.conversation_history:
                self.conversation_history[event.chat_id] = []
            
            self.conversation_history[event.chat_id].append({
                'text': original_text,
                'translated': translated,
                'time': datetime.now()
            })
            
            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è Heroku
            if len(self.conversation_history[event.chat_id]) > 10:
                self.conversation_history[event.chat_id].pop(0)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
            await self.send_translation_response(event, original_text, translated)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            self.stats['total_translations'] += 1
            self.stats['total_characters'] += len(original_text)
            self.stats['last_translation'] = datetime.now()
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–µ—Ä–µ–≤–æ–¥–∞: {e}")
            self.stats['errors'] += 1
    
    async def get_translation(self, text: str, context: str = "") -> Optional[str]:
        """
        –ü–æ–ª—É—á–∞–µ—Ç –ø–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
        """
        if len(text) > self.settings['max_length']:
            text = text[:self.settings['max_length']] + "..."
        
        cache_key = self.get_cache_key(text, context)
        if self.settings['cache_enabled'] and cache_key in self.translation_cache:
            self.stats['cache_hits'] += 1
            return self.translation_cache[cache_key]
        
        # –ó–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è —Å–æ–±–ª—é–¥–µ–Ω–∏—è rate limit
        if self.stats['api_calls'] % 5 == 0 and self.stats['api_calls'] > 0:
            await asyncio.sleep(2)
        
        translated = await self.call_gemini_api(text, context)
        
        if translated and self.settings['cache_enabled']:
            self.translation_cache[cache_key] = translated
            
            if len(self.translation_cache) > self.settings['cache_size']:
                self.translation_cache.pop(next(iter(self.translation_cache)))
        
        return translated
    
    async def send_translation_response(self, event, original_text: str, translated_text: str):
        """
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ —á–∞—Ç
        """
        try:
            response_parts = []
            
            if self.settings['show_original']:
                response_parts.append(f"üá∑üá∫ **–û—Ä–∏–≥–∏–Ω–∞–ª:**\n{original_text}")
            
            response_parts.append(f"üá∫üá∏ **–ü–µ—Ä–µ–≤–æ–¥:**\n{translated_text}")
            
            if self.settings['show_transliteration']:
                translit = self.transliterate_russian(original_text)
                response_parts.append(f"üî§ **–¢—Ä–∞–Ω—Å–ª–∏—Ç:**\n{translit}")
            
            response_parts.append("_‚ú® Google Gemini AI_")
            
            response = "\n\n".join(response_parts)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
            try:
                await event.respond(response, parse_mode='md')
            except Exception as e:
                logger.warning(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å —Ä–∞–∑–º–µ—Ç–∫–æ–π: {e}, –æ—Ç–ø—Ä–∞–≤–∫–∞ –±–µ–∑ —Ä–∞–∑–º–µ—Ç–∫–∏")
                response_plain = response.replace('**', '').replace('_', '')
                await event.respond(response_plain)
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞: {e}")
    
    def transliterate_russian(self, text: str) -> str:
        """
        –ü—Ä–æ—Å—Ç–∞—è —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è —Ä—É—Å—Å–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
        """
        translit_dict = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd',
            '–µ': 'e', '—ë': 'yo', '–∂': 'zh', '–∑': 'z', '–∏': 'i',
            '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm', '–Ω': 'n',
            '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't',
            '—É': 'u', '—Ñ': 'f', '—Ö': 'kh', '—Ü': 'ts', '—á': 'ch',
            '—à': 'sh', '—â': 'shch', '—ä': '', '—ã': 'y', '—å': '',
            '—ç': 'e', '—é': 'yu', '—è': 'ya',
        }
        
        result = []
        for char in text:
            if char.lower() in translit_dict:
                if char.isupper():
                    result.append(translit_dict[char.lower()].capitalize())
                else:
                    result.append(translit_dict[char])
            else:
                result.append(char)
        
        return ''.join(result)
    
    async def manual_translation(self, event, text: str):
        """–†—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥ –ø–æ –∫–æ–º–∞–Ω–¥–µ"""
        try:
            translated = await self.get_translation(text)
            
            if translated:
                await event.reply(
                    f"**üìù –†—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥:**\n\n"
                    f"üá∑üá∫ **–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç:**\n{text}\n\n"
                    f"üá∫üá∏ **–ü–µ—Ä–µ–≤–æ–¥:**\n{translated}\n\n"
                    f"_‚ú® Google Gemini AI_",
                    parse_mode='md'
                )
            else:
                await event.reply("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ API –∫–ª—é—á.")
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Ä—É—á–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞: {e}")
            await event.reply(f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: {str(e)}")
    
    async def handle_settings(self, event, args: Optional[str]):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ –Ω–∞—Å—Ç—Ä–æ–µ–∫"""
        if not args:
            settings_text = self.format_settings()
            await event.reply(settings_text, parse_mode='md')
            return
        
        args = args.strip().lower()
        
        if args == "on":
            self.settings['auto_translate'] = True
            await event.reply("‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ –≤–∫–ª—é—á–µ–Ω")
        
        elif args == "off":
            self.settings['auto_translate'] = False
            await event.reply("‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ –≤—ã–∫–ª—é—á–µ–Ω")
        
        elif args.startswith("lang "):
            lang = args.split(" ", 1)[1]
            if lang in ['en', 'english', '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π']:
                self.settings['target_language'] = '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π'
                await event.reply("‚úÖ –¶–µ–ª–µ–≤–æ–π —è–∑—ã–∫: –ê–Ω–≥–ª–∏–π—Å–∫–∏–π")
            elif lang in ['ru', 'russian', '—Ä—É—Å—Å–∫–∏–π']:
                self.settings['target_language'] = '—Ä—É—Å—Å–∫–∏–π'
                await event.reply("‚úÖ –¶–µ–ª–µ–≤–æ–π —è–∑—ã–∫: –†—É—Å—Å–∫–∏–π")
            else:
                await event.reply("‚ùå –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ: en/english –∏–ª–∏ ru/russian")
        
        elif args == "formal on":
            self.settings['formal_tone'] = True
            await event.reply("‚úÖ –§–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω –ø–µ—Ä–µ–≤–æ–¥–∞ –≤–∫–ª—é—á–µ–Ω")
        
        elif args == "formal off":
            self.settings['formal_tone'] = False
            await event.reply("‚úÖ –§–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω –ø–µ—Ä–µ–≤–æ–¥–∞ –≤—ã–∫–ª—é—á–µ–Ω")
        
        elif args == "context on":
            self.settings['context_aware'] = True
            await event.reply("‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –≤–∫–ª—é—á–µ–Ω")
        
        elif args == "context off":
            self.settings['context_aware'] = False
            await event.reply("‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –≤—ã–∫–ª—é—á–µ–Ω")
        
        elif args == "help":
            await self.show_help(event)
        
        else:
            await event.reply(
                "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ:\n"
                "‚Ä¢ `!transsettings` - –ø–æ–∫–∞–∑–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n"
                "‚Ä¢ `!transsettings on/off` - –≤–∫–ª/–≤—ã–∫–ª –∞–≤—Ç–æ-–ø–µ—Ä–µ–≤–æ–¥\n"
                "‚Ä¢ `!transsettings lang en/ru` - –∏–∑–º–µ–Ω–∏—Ç—å —è–∑—ã–∫\n"
                "‚Ä¢ `!transsettings formal on/off` - —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω\n"
                "‚Ä¢ `!transsettings context on/off` - –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥\n"
                "‚Ä¢ `!transsettings help` - –ø–æ–º–æ—â—å"
            )
    
    def format_settings(self) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
        settings_list = []
        for key, value in self.settings.items():
            if isinstance(value, bool):
                value_str = "‚úÖ –í–ö–õ" if value else "‚ùå –í–´–ö–õ"
            else:
                value_str = str(value)
            settings_list.append(f"**{key}:** {value_str}")
        
        return "**‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞:**\n\n" + "\n".join(settings_list)
    
    async def show_stats(self, event):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
        uptime = datetime.now() - self.stats['start_time']
        hours, remainder = divmod(uptime.total_seconds(), 3600)
        minutes, seconds = divmod(remainder, 60)
        
        last_trans = self.stats['last_translation']
        last_time = last_trans.strftime("%H:%M:%S") if last_trans else "–Ω–∏–∫–æ–≥–¥–∞"
        
        stats_text = (
            f"**üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞:**\n\n"
            f"‚Ä¢ –í—Å–µ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–æ–≤: **{self.stats['total_translations']}**\n"
            f"‚Ä¢ –°–∏–º–≤–æ–ª–æ–≤ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ: **{self.stats['total_characters']:,}**\n"
            f"‚Ä¢ –ó–∞–ø—Ä–æ—Å–æ–≤ –∫ API: **{self.stats['api_calls']}**\n"
            f"‚Ä¢ –ü–æ–ø–∞–¥–∞–Ω–∏–π –≤ –∫—ç—à: **{self.stats['cache_hits']}**\n"
            f"‚Ä¢ –û—à–∏–±–æ–∫: **{self.stats['errors']}**\n"
            f"‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø–µ—Ä–µ–≤–æ–¥: **{last_time}**\n"
            f"‚Ä¢ –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: **{int(hours)}—á {int(minutes)}–º {int(seconds)}—Å**\n"
            f"‚Ä¢ –†–∞–∑–º–µ—Ä –∫—ç—à–∞: **{len(self.translation_cache)}/{self.settings['cache_size']}**\n"
            f"‚Ä¢ –ú–æ–¥–µ–ª—å: **{self.model}**\n"
            f"‚Ä¢ –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞: **Heroku**"
        )
        
        await event.reply(stats_text, parse_mode='md')
    
    async def show_help(self, event):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É"""
        help_text = (
            "**ü§ñ Gemini –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ –¥–ª—è Telegram (Heroku)**\n\n"
            "**–û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:**\n"
            "‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ —Ä—É—Å—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π\n"
            "‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞\n"
            "‚Ä¢ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤\n"
            "‚Ä¢ –§–æ—Ä–º–∞–ª—å–Ω—ã–π/–Ω–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω\n"
            "‚Ä¢ –¢—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è\n\n"
            "**–ö–æ–º–∞–Ω–¥—ã:**\n"
            "‚Ä¢ –ü—Ä–æ—Å—Ç–æ –ø–∏—à–∏—Ç–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥\n"
            "‚Ä¢ `!tr [—Ç–µ–∫—Å—Ç]` - —Ä—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥\n"
            "‚Ä¢ `!translate [—Ç–µ–∫—Å—Ç]` - —Ä—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥\n"
            "‚Ä¢ `!transsettings` - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n"
            "‚Ä¢ `!trstats` - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n"
            "‚Ä¢ `!trreload` - –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ –∫—ç—à–∞\n"
            "‚Ä¢ `!trhelp` - —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n\n"
            "**–ù–∞—Å—Ç—Ä–æ–π–∫–∏:**\n"
            "‚Ä¢ `!transsettings on/off` - –≤–∫–ª/–≤—ã–∫–ª –∞–≤—Ç–æ-–ø–µ—Ä–µ–≤–æ–¥\n"
            "‚Ä¢ `!transsettings lang en/ru` - —Ü–µ–ª–µ–≤–æ–π —è–∑—ã–∫\n"
            "‚Ä¢ `!transsettings formal on/off` - —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω\n"
            "‚Ä¢ `!transsettings context on/off` - –∫–æ–Ω—Ç–µ–∫—Å—Ç\n\n"
            "**–ò—Å–ø–æ–ª—å–∑—É–µ—Ç:** Google Gemini Pro AI\n"
            f"**–ú–æ–¥–µ–ª—å:** {self.model}\n"
            "**–í–µ—Ä—Å–∏—è:** Heroku Optimized"
        )
        
        await event.reply(help_text, parse_mode='md')


# ==================== –§–£–ù–ö–¶–ò–Ø –†–ï–ì–ò–°–¢–†–ê–¶–ò–ò –î–õ–Ø HEROKU ====================

def register(bot):
    """
    –§—É–Ω–∫—Ü–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –º–æ–¥—É–ª—è –¥–ª—è Heroku
    –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
    """
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ API –∫–ª—é—á–µ–π
        api_id = os.getenv('API_ID')
        api_hash = os.getenv('API_HASH')
        gemini_key = os.getenv('GEMINI_API_KEY')
        
        if not api_id or not api_hash:
            logger.error("API_ID –∏ API_HASH –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è!")
            return False
        
        if not gemini_key:
            logger.error("GEMINI_API_KEY –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
            return False
        
        # –°–æ–∑–¥–∞–µ–º –∫–ª–∏–µ–Ω—Ç Telegram
        session_name = os.getenv('SESSION_NAME', 'gemini_translator')
        client = TelegramClient(session_name, int(api_id), api_hash)
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫
        translator = GeminiTranslator(client, gemini_key)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫–∏ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞
        bot.client = client
        bot.translator = translator
        
        logger.info("‚úÖ –ú–æ–¥—É–ª—å Gemini Translator –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –¥–ª—è Heroku")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –∫–ª–∏–µ–Ω—Ç –≤ —Ñ–æ–Ω–µ
        async def start_client():
            await client.start()
            logger.info(f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {await client.get_me()}")
            await client.run_until_disconnected()
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∑–∞–¥–∞—á–µ
        import threading
        client_thread = threading.Thread(target=lambda: asyncio.run(start_client()), daemon=True)
        client_thread.start()
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –º–æ–¥—É–ª—è: {e}")
        return False


# ==================== –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ù–´–ô –ó–ê–ü–£–°–ö ====================

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –¥–ª—è —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è"""
    print("üöÄ –ó–∞–ø—É—Å–∫ Gemini Translator...")
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
    api_id = os.getenv('API_ID')
    api_hash = os.getenv('API_HASH')
    gemini_api_key = os.getenv('GEMINI_API_KEY')
    
    if not api_id or not api_hash:
        print("‚ùå –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ API_ID –∏ API_HASH –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è!")
        return
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∏–µ–Ω—Ç
    session_name = os.getenv('SESSION_NAME', 'gemini_translator')
    client = TelegramClient(session_name, int(api_id), api_hash)
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫
    translator = GeminiTranslator(client, gemini_api_key)
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º
    await client.start()
    
    print(f"‚úÖ Gemini Translator –∑–∞–ø—É—â–µ–Ω!")
    print(f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {await client.get_me()}")
    print(f"ü§ñ –ú–æ–¥–µ–ª—å AI: {translator.model}")
    print(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: !trstats")
    print(f"üÜò –ü–æ–º–æ—â—å: !trhelp")
    
    await client.run_until_disconnected()

if __name__ == '__main__':
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–µ–∂–∏–º –∑–∞–ø—É—Å–∫–∞
    if 'HEROKU' in os.environ or 'DYNO' in os.environ:
        print("üåê –ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ Heroku")
        # –í Heroku –º–æ–¥—É–ª—å –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä–µ–∑ register()
    else:
        # –õ–æ–∫–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫
        asyncio.run(main())
