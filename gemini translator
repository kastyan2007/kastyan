#!/usr/bin/env python3
"""
Gemini Translator –¥–ª—è Telegram - –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ API –∫–ª—é—á–∞–º–∏
–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ —Ä—É—Å—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π —á–µ—Ä–µ–∑ Google Gemini API
"""

import os
import asyncio
import hashlib
import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, List
import aiohttp
from telethon import TelegramClient, events
from telethon.tl import types
import logging

# ==================== –§–ò–ö–°–ò–†–û–í–ê–ù–ù–´–ï API –ö–õ–Æ–ß–ò TELEGRAM ====================
# –î–∞–Ω–Ω—ã–µ –∏–∑ Telegram Desktop
FIXED_API_ID = 2040
FIXED_API_HASH = "b18441a1ff607e10a989891a5462e627"
FIXED_APP_NAME = "Telegram Desktop"
# =========================================================================

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class GeminiTranslator:
    """
    –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ –Ω–∞ –æ—Å–Ω–æ–≤–µ Google Gemini AI
    –í–µ—Ä—Å–∏—è —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ API –∫–ª—é—á–∞–º–∏ Telegram
    """
    
    def __init__(self, client: TelegramClient, gemini_api_key: Optional[str] = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞ —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∫–ª—é—á–∞–º–∏
        
        Args:
            client: Telethon –∫–ª–∏–µ–Ω—Ç (—É–∂–µ —Å–æ–∑–¥–∞–Ω–Ω—ã–π —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∫–ª—é—á–∞–º–∏)
            gemini_api_key: –ö–ª—é—á API Google Gemini
        """
        self.client = client
        
        # –ü–æ–ª—É—á–∞–µ–º Gemini API –∫–ª—é—á
        self.api_key = gemini_api_key or os.getenv('GEMINI_API_KEY')
        
        if not self.api_key:
            # –ü—Ä–æ–±—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∏–º–µ–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
            self.api_key = os.getenv('GOOGLE_AI_API_KEY') or os.getenv('GOOGLE_API_KEY')
        
        if not self.api_key:
            logger.error("GEMINI_API_KEY –Ω–µ –Ω–∞–π–¥–µ–Ω!")
            logger.error("–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: GEMINI_API_KEY='–≤–∞—à_–∫–ª—é—á_–∑–¥–µ—Å—å'")
            raise ValueError(
                "–¢—Ä–µ–±—É–µ—Ç—Å—è Gemini API –∫–ª—é—á. –ü–æ–ª—É—á–∏—Ç–µ –Ω–∞: https://makersuite.google.com/app/apikey"
            )
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª—é—á
        self.validate_api_key()
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        self.settings = {
            'auto_translate': True,
            'target_language': '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π',
            'source_language': '—Ä—É—Å—Å–∫–∏–π',
            'show_original': True,
            'show_transliteration': False,
            'context_aware': True,
            'formal_tone': False,
            'preserve_formatting': True,
            'max_length': 4000,
            'cache_enabled': True,
            'cache_size': 1000,
            'rate_limit': 20,
            'ignore_commands': True,
            'ignore_links': False,
            'smart_language_detection': True,
            'reply_in_thread': False,
            'use_web_preview': False,
            'translate_media_captions': True,
            'auto_delete_original': False,
            'translation_timeout': 30,
        }
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è API
        self.base_url = "https://generativelanguage.googleapis.com/v1beta/models"
        self.model = "gemini-1.5-pro-latest"  # –ê–∫—Ç—É–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å
        
        # –ö—ç—à –ø–µ—Ä–µ–≤–æ–¥–æ–≤
        self.translation_cache: Dict[str, str] = {}
        self.language_cache: Dict[str, str] = {}
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = {
            'total_translations': 0,
            'total_characters': 0,
            'cache_hits': 0,
            'api_calls': 0,
            'errors': 0,
            'start_time': datetime.now(),
            'last_translation': None,
            'api_keys_used': 'Telegram Desktop Fixed Keys',
        }
        
        # –ò—Å—Ç–æ—Ä–∏—è –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞
        self.conversation_history: Dict[int, List[Dict]] = {}
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
        self.setup_handlers()
        
        logger.info(f"Gemini Translator –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        logger.info(f"Telegram API: ID={FIXED_API_ID}, Hash={FIXED_API_HASH[:8]}...")
        logger.info(f"AI –ú–æ–¥–µ–ª—å: {self.model}")
    
    def validate_api_key(self) -> bool:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è API –∫–ª—é—á–∞"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç –∫–ª—é—á–∞ Gemini
            if not self.api_key.startswith('AIza'):
                logger.warning("–ö–ª—é—á –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–º –¥–ª—è Gemini API")
            
            # –ú–∞—Å–∫–∏—Ä—É–µ–º –∫–ª—é—á –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            masked_key = self.api_key[:8] + '...' + self.api_key[-4:] if len(self.api_key) > 12 else '***'
            logger.info(f"Gemini API –∫–ª—é—á: {masked_key}")
            return True
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ API –∫–ª—é—á–∞: {e}")
            return False
    
    def setup_handlers(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π Telegram"""
        
        # –û—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        @self.client.on(events.NewMessage(outgoing=True))
        async def outgoing_message_handler(event):
            """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
            if not self.settings['auto_translate']:
                return
            
            message_text = event.message.message
            if not message_text or len(message_text.strip()) == 0:
                return
            
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ
            if self.settings['ignore_commands'] and message_text.startswith(('/', '!', '.')):
                return
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–∑—ã–∫
            if self.should_translate(message_text):
                await self.handle_translation(event, message_text)
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ —Ä—É—Å—Å–∫–∏–π)
        @self.client.on(events.NewMessage(incoming=True))
        async def incoming_message_handler(event):
            """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
            if not self.settings['auto_translate']:
                return
            
            # –¢–æ–ª—å–∫–æ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –≥—Ä—É–ø–ø—ã
            if event.is_private or event.is_group:
                message_text = event.message.message
                if message_text and self.is_english_text(message_text):
                    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ –∞–Ω–≥–ª–∏–π—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ —Ä—É—Å—Å–∫–∏–π
                    await self.handle_incoming_translation(event, message_text, 'en-ru')
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞
        @self.client.on(events.NewMessage(pattern=r'^!tr(?:anslate)?\s+(.+)$'))
        async def manual_translate_handler(event):
            """–†—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥ –ø–æ –∫–æ–º–∞–Ω–¥–µ"""
            text_to_translate = event.pattern_match.group(1).strip()
            if text_to_translate:
                await self.manual_translation(event, text_to_translate)
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫
        @self.client.on(events.NewMessage(pattern=r'^!transsettings\s*(.+)?$'))
        async def settings_handler(event):
            """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏"""
            args = event.pattern_match.group(1)
            await self.handle_settings(event, args)
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        @self.client.on(events.NewMessage(pattern='^!trstats$'))
        async def stats_handler(event):
            """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
            await self.show_stats(event)
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø–æ–º–æ—â–∏
        @self.client.on(events.NewMessage(pattern='^!trhelp$'))
        async def help_handler(event):
            """–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–º–æ—â—å"""
            await self.show_help(event)
        
        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –≤—Å–µ–≥–æ —á–∞—Ç–∞
        @self.client.on(events.NewMessage(pattern='^!trchat\s*(\d+)?$'))
        async def translate_chat_handler(event):
            """–ü–µ—Ä–µ–≤–æ–¥ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç–µ"""
            limit = int(event.pattern_match.group(1) or 5)
            await self.translate_chat_history(event, limit)
        
        logger.info("–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã")
    
    def should_translate(self, text: str) -> bool:
        """
        –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å —Ç–µ–∫—Å—Ç
        """
        if not text or len(text.strip()) < 2:
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        text_hash = hashlib.md5(text.encode()).hexdigest()
        if text_hash in self.language_cache:
            return self.language_cache[text_hash] == 'ru'
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–∑—ã–∫
        detected_lang = self.detect_language_simple(text)
        self.language_cache[text_hash] = detected_lang
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∫—ç—à–∞
        if len(self.language_cache) > 500:
            self.language_cache.pop(next(iter(self.language_cache)))
        
        return detected_lang == 'ru'
    
    def detect_language_simple(self, text: str) -> str:
        """
        –ü—Ä–æ—Å—Ç–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞ (—Ä—É—Å—Å–∫–∏–π/–∞–Ω–≥–ª–∏–π—Å–∫–∏–π/–¥—Ä—É–≥–æ–π)
        """
        ru_count = 0
        en_count = 0
        total_alpha = 0
        
        for char in text.lower():
            if '–∞' <= char <= '—è' or char == '—ë':
                ru_count += 1
                total_alpha += 1
            elif 'a' <= char <= 'z':
                en_count += 1
                total_alpha += 1
        
        if total_alpha == 0:
            return 'other'
        
        ru_ratio = ru_count / total_alpha
        en_ratio = en_count / total_alpha
        
        if ru_ratio > 0.6:
            return 'ru'
        elif en_ratio > 0.6:
            return 'en'
        else:
            return 'other'
    
    def is_english_text(self, text: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç –∞–Ω–≥–ª–∏–π—Å–∫–∏–º"""
        return self.detect_language_simple(text) == 'en'
    
    def is_russian_text(self, text: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç —Ä—É—Å—Å–∫–∏–º"""
        return self.detect_language_simple(text) == 'ru'
    
    def get_cache_key(self, text: str, context: str = "", direction: str = "ru-en") -> str:
        """–°–æ–∑–¥–∞–µ—Ç –∫–ª—é—á –¥–ª—è –∫—ç—à–∞ –ø–µ—Ä–µ–≤–æ–¥–æ–≤"""
        key_string = f"{text}_{direction}_{context}_{self.settings['formal_tone']}"
        return hashlib.md5(key_string.encode()).hexdigest()
    
    async def call_gemini_api(self, prompt: str, context: str = "", direction: str = "ru-en") -> Optional[str]:
        """
        –í—ã–∑–æ–≤ Google Gemini API
        
        Args:
            prompt: –¢–µ–∫—Å—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç –ø–µ—Ä–µ–≤–æ–¥–∞
            direction: –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–∞ (ru-en –∏–ª–∏ en-ru)
        """
        self.stats['api_calls'] += 1
        
        url = f"{self.base_url}/{self.model}:generateContent?key={self.api_key}"
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–∞
        if direction == "ru-en":
            source_lang = "—Ä—É—Å—Å–∫–æ–≥–æ"
            target_lang = "–∞–Ω–≥–ª–∏–π—Å–∫–∏–π"
        else:  # en-ru
            source_lang = "–∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ"
            target_lang = "—Ä—É—Å—Å–∫–∏–π"
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç
        full_prompt = self.build_prompt(prompt, context, source_lang, target_lang)
        
        headers = {
            "Content-Type": "application/json",
        }
        
        payload = {
            "contents": [
                {
                    "parts": [
                        {"text": full_prompt}
                    ]
                }
            ],
            "generationConfig": {
                "temperature": 0.1,  # –û—á–µ–Ω—å –Ω–∏–∑–∫–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏
                "topK": 1,
                "topP": 0.95,
                "maxOutputTokens": 4096,
            },
            "safetySettings": [
                {
                    "category": "HARM_CATEGORY_HARASSMENT",
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_HATE_SPEECH", 
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                    "threshold": "BLOCK_NONE"
                }
            ]
        }
        
        try:
            timeout = aiohttp.ClientTimeout(total=self.settings['translation_timeout'])
            async with aiohttp.ClientSession(timeout=timeout) as session:
                async with session.post(url, headers=headers, json=payload) as response:
                    
                    if response.status == 200:
                        data = await response.json()
                        
                        if 'candidates' in data and len(data['candidates']) > 0:
                            candidate = data['candidates'][0]
                            if 'content' in candidate and 'parts' in candidate['content']:
                                if len(candidate['content']['parts']) > 0:
                                    translated_text = candidate['content']['parts'][0]['text']
                                    cleaned_text = self.clean_gemini_response(translated_text)
                                    return cleaned_text
                    
                    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
                    error_text = await response.text()
                    logger.error(f"Gemini API Error {response.status}: {error_text[:200]}")
                    
                    if response.status == 429:
                        logger.warning("–î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤")
                        await asyncio.sleep(5)
                        return await self.fallback_translation(prompt, direction)
                    
                    return None
                    
        except asyncio.TimeoutError:
            logger.error("Gemini API timeout")
            return await self.fallback_translation(prompt, direction)
        except Exception as e:
            logger.error(f"Gemini API exception: {e}")
            self.stats['errors'] += 1
            return await self.fallback_translation(prompt, direction)
    
    def build_prompt(self, text: str, context: str = "", source_lang: str = "—Ä—É—Å—Å–∫–æ–≥–æ", target_lang: str = "–∞–Ω–≥–ª–∏–π—Å–∫–∏–π") -> str:
        """
        –°—Ç—Ä–æ–∏—Ç –ø—Ä–æ–º–ø—Ç –¥–ª—è Gemini API
        """
        tone = "—Ñ–æ—Ä–º–∞–ª—å–Ω–æ–º" if self.settings['formal_tone'] else "–µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–º"
        
        prompt_parts = [
            f"–¢—ã –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ —Å {source_lang} –Ω–∞ {target_lang}.",
            f"–ü–µ—Ä–µ–≤–µ–¥–∏ —Å–ª–µ–¥—É—é—â–∏–π —Ç–µ–∫—Å—Ç —Å {source_lang} –Ω–∞ {target_lang} –≤ {tone} —Å—Ç–∏–ª–µ:",
            "",
            f"–¢–ï–ö–°–¢ –î–õ–Ø –ü–ï–†–ï–í–û–î–ê:",
            f"```",
            f"{text}",
            f"```",
        ]
        
        if context and self.settings['context_aware']:
            prompt_parts.extend([
                "",
                "–ö–û–ù–¢–ï–ö–°–¢ –†–ê–ó–ì–û–í–û–†–ê:",
                f"{context}",
                "",
                "–£—á—Ç–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–∏ –ø–µ—Ä–µ–≤–æ–¥–µ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–º—ã—Å–ª–∞."
            ])
        
        prompt_parts.extend([
            "",
            "–°–¢–†–û–ì–ò–ï –ü–†–ê–í–ò–õ–ê –ü–ï–†–ï–í–û–î–ê:",
            "1. –°–æ—Ö—Ä–∞–Ω—è–π —Ç–æ—á–Ω—ã–π —Å–º—ã—Å–ª –æ—Ä–∏–≥–∏–Ω–∞–ª–∞",
            "2. –ò—Å–ø–æ–ª—å–∑—É–π –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π, —Ä–∞–∑–≥–æ–≤–æ—Ä–Ω—ã–π —è–∑—ã–∫",
            "3. –°–æ—Ö—Ä–∞–Ω—è–π –≤—Å–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (–ø–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫, —ç–º–æ–¥–∑–∏)",
            "4. –ù–µ –¥–æ–±–∞–≤–ª—è–π –Ω–∏–∫–∞–∫–∏—Ö –ø–æ—è—Å–Ω–µ–Ω–∏–π –∏–ª–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤",
            "5. –ù–µ –ø–µ—Ä–µ–≤–æ–¥–∏ –∏–º–µ–Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ, –±—Ä–µ–Ω–¥—ã, –Ω–∞–∑–≤–∞–Ω–∏—è",
            "6. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ç–µ—Ä–º–∏–Ω—ã –æ—Å—Ç–∞–≤–ª—è–π –±–µ–∑ –ø–µ—Ä–µ–≤–æ–¥–∞ –µ—Å–ª–∏ –Ω–µ—Ç —Ç–æ—á–Ω–æ–≥–æ –∞–Ω–∞–ª–æ–≥–∞",
            "7. –°–ª–µ–Ω–≥ –∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –ø–µ—Ä–µ–≤–æ–¥–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º–∏ –∞–Ω–∞–ª–æ–≥–∞–º–∏",
            "8. –°–æ—Ö—Ä–∞–Ω—è–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—É—é –æ–∫—Ä–∞—Å–∫—É —Ç–µ–∫—Å—Ç–∞",
            "",
            "–í–ê–ñ–ù–û: –û—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –¢–û–õ–¨–ö–û –ø–µ—Ä–µ–≤–æ–¥, –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞."
        ])
        
        return "\n".join(prompt_parts)
    
    def clean_gemini_response(self, text: str) -> str:
        """–û—á–∏—â–∞–µ—Ç –æ—Ç–≤–µ—Ç –æ—Ç Gemini"""
        # –£–±–∏—Ä–∞–µ–º –∫–∞–≤—ã—á–∫–∏ –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç –æ–±–µ—Ä–Ω—É—Ç –≤ –Ω–∏—Ö
        if (text.startswith('"') and text.endswith('"')) or (text.startswith("'") and text.endswith("'")):
            text = text[1:-1]
        
        # –£–±–∏—Ä–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ/–∫–æ–Ω–µ—á–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã
        text = text.strip()
        
        # –£–±–∏—Ä–∞–µ–º –º–µ—Ç–∫–∏ –ø–µ—Ä–µ–≤–æ–¥–∞ –µ—Å–ª–∏ –µ—Å—Ç—å
        remove_phrases = ["–ü–µ—Ä–µ–≤–æ–¥:", "Translation:", "–í–æ—Ç –ø–µ—Ä–µ–≤–æ–¥:", "Here's the translation:", "```", "–ü–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:"]
        for phrase in remove_phrases:
            if text.startswith(phrase):
                text = text[len(phrase):].strip()
        
        return text
    
    async def fallback_translation(self, text: str, direction: str = "ru-en") -> Optional[str]:
        """
        –ó–∞–ø–∞—Å–Ω–æ–π –º–µ—Ç–æ–¥ –ø–µ—Ä–µ–≤–æ–¥–∞ –µ—Å–ª–∏ Gemini –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
        """
        logger.info(f"–ò—Å–ø–æ–ª—å–∑—É—é fallback –ø–µ—Ä–µ–≤–æ–¥ ({direction})")
        
        if direction == "ru-en":
            # –†—É—Å—Å–∫–æ-–∞–Ω–≥–ª–∏–π—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å
            common_phrases = {
                "–ø—Ä–∏–≤–µ—Ç": "hello",
                "–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ": "hello",
                "–∫–∞–∫ –¥–µ–ª–∞": "how are you",
                "—á—Ç–æ –Ω–æ–≤–æ–≥–æ": "what's new",
                "—Å–ø–∞—Å–∏–±–æ": "thank you",
                "–±–æ–ª—å—à–æ–µ —Å–ø–∞—Å–∏–±–æ": "thank you very much",
                "–ø–æ–∂–∞–ª—É–π—Å—Ç–∞": "you're welcome",
                "–∏–∑–≤–∏–Ω–∏—Ç–µ": "sorry",
                "–ø—Ä–æ—Å—Ç–∏—Ç–µ": "excuse me",
                "–¥–∞": "yes",
                "–Ω–µ—Ç": "no",
                "—Ö–æ—Ä–æ—à–æ": "good",
                "–æ—Ç–ª–∏—á–Ω–æ": "excellent",
                "–ø–ª–æ—Ö–æ": "bad",
                "—É–∂–∞—Å–Ω–æ": "terrible",
                "—á—Ç–æ –¥–µ–ª–∞–µ—à—å": "what are you doing",
                "–∫–∞–∫ –∂–∏–∑–Ω—å": "how's life",
                "–¥–æ —Å–≤–∏–¥–∞–Ω–∏—è": "goodbye",
                "–ø–æ–∫–∞": "bye",
                "—É–≤–∏–¥–∏–º—Å—è": "see you",
            }
        else:
            # –ê–Ω–≥–ª–æ-—Ä—É—Å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å
            common_phrases = {
                "hello": "–ø—Ä–∏–≤–µ—Ç",
                "hi": "–ø—Ä–∏–≤–µ—Ç",
                "how are you": "–∫–∞–∫ –¥–µ–ª–∞",
                "what's up": "—á—Ç–æ –Ω–æ–≤–æ–≥–æ",
                "thank you": "—Å–ø–∞—Å–∏–±–æ",
                "thanks": "—Å–ø–∞—Å–∏–±–æ",
                "you're welcome": "–ø–æ–∂–∞–ª—É–π—Å—Ç–∞",
                "sorry": "–∏–∑–≤–∏–Ω–∏—Ç–µ",
                "excuse me": "–ø—Ä–æ—Å—Ç–∏—Ç–µ",
                "yes": "–¥–∞",
                "no": "–Ω–µ—Ç",
                "good": "—Ö–æ—Ä–æ—à–æ",
                "great": "–æ—Ç–ª–∏—á–Ω–æ",
                "bad": "–ø–ª–æ—Ö–æ",
                "terrible": "—É–∂–∞—Å–Ω–æ",
                "what are you doing": "—á—Ç–æ –¥–µ–ª–∞–µ—à—å",
                "how's life": "–∫–∞–∫ –∂–∏–∑–Ω—å",
                "goodbye": "–¥–æ —Å–≤–∏–¥–∞–Ω–∏—è",
                "bye": "–ø–æ–∫–∞",
                "see you": "—É–≤–∏–¥–∏–º—Å—è",
            }
        
        text_lower = text.lower()
        for phrase, translation in common_phrases.items():
            if phrase in text_lower:
                return translation
        
        return None
    
    async def handle_translation(self, event, original_text: str):
        """
        –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏—è (—Ä—É—Å—Å–∫–∏–π -> –∞–Ω–≥–ª–∏–π—Å–∫–∏–π)
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏
            context = ""
            if self.settings['context_aware'] and event.chat_id in self.conversation_history:
                recent_messages = self.conversation_history[event.chat_id][-5:]
                context = " | ".join([msg.get('text', '') for msg in recent_messages])
            
            # –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥
            translated = await self.get_translation(original_text, context, "ru-en")
            
            if not translated:
                logger.warning(f"–ü–µ—Ä–µ–≤–æ–¥ –Ω–µ –ø–æ–ª—É—á–µ–Ω –¥–ª—è: {original_text[:50]}...")
                return
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é
            if event.chat_id not in self.conversation_history:
                self.conversation_history[event.chat_id] = []
            
            self.conversation_history[event.chat_id].append({
                'text': original_text,
                'translated': translated,
                'time': datetime.now(),
                'direction': 'ru-en'
            })
            
            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏
            if len(self.conversation_history[event.chat_id]) > 20:
                self.conversation_history[event.chat_id].pop(0)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
            await self.send_translation_response(event, original_text, translated, "ru-en")
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            self.stats['total_translations'] += 1
            self.stats['total_characters'] += len(original_text)
            self.stats['last_translation'] = datetime.now()
            
            # –£–¥–∞–ª—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ
            if self.settings['auto_delete_original']:
                await asyncio.sleep(1)
                await event.delete()
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–µ—Ä–µ–≤–æ–¥–∞: {e}")
            self.stats['errors'] += 1
    
    async def handle_incoming_translation(self, event, original_text: str, direction: str = "en-ru"):
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–∞–Ω–≥–ª–∏–π—Å–∫–∏–π -> —Ä—É—Å—Å–∫–∏–π)
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥
            translated = await self.get_translation(original_text, "", direction)
            
            if translated:
                # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç –¥–ª—è –≤—Ö–æ–¥—è—â–∏—Ö
                response = (
                    f"üá∫üá∏ **Original:**\n{original_text}\n\n"
                    f"üá∑üá∫ **–ü–µ—Ä–µ–≤–æ–¥:**\n{translated}\n\n"
                    f"_‚ú® –ê–≤—Ç–æ–ø–µ—Ä–µ–≤–æ–¥ —Å –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ_"
                )
                
                await event.reply(response, parse_mode='md')
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞ –≤—Ö–æ–¥—è—â–µ–≥–æ: {e}")
    
    async def get_translation(self, text: str, context: str = "", direction: str = "ru-en") -> Optional[str]:
        """
        –ü–æ–ª—É—á–∞–µ—Ç –ø–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
        """
        if len(text) > self.settings['max_length']:
            text = text[:self.settings['max_length']] + "..."
        
        cache_key = self.get_cache_key(text, context, direction)
        if self.settings['cache_enabled'] and cache_key in self.translation_cache:
            self.stats['cache_hits'] += 1
            return self.translation_cache[cache_key]
        
        # –ó–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è —Å–æ–±–ª—é–¥–µ–Ω–∏—è rate limit
        if self.stats['api_calls'] > 0 and self.stats['api_calls'] % self.settings['rate_limit'] == 0:
            await asyncio.sleep(60)  # –ñ–¥–µ–º –º–∏–Ω—É—Ç—É –µ—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ –ª–∏–º–∏—Ç–∞
        
        translated = await self.call_gemini_api(text, context, direction)
        
        if translated and self.settings['cache_enabled']:
            self.translation_cache[cache_key] = translated
            
            if len(self.translation_cache) > self.settings['cache_size']:
                self.translation_cache.pop(next(iter(self.translation_cache)))
        
        return translated
    
    async def send_translation_response(self, event, original_text: str, translated_text: str, direction: str = "ru-en"):
        """
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ —á–∞—Ç
        """
        try:
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–ª–∞–≥–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            if direction == "ru-en":
                source_flag = "üá∑üá∫"
                target_flag = "üá∫üá∏"
                source_label = "–û—Ä–∏–≥–∏–Ω–∞–ª"
                target_label = "–ü–µ—Ä–µ–≤–æ–¥"
            else:
                source_flag = "üá∫üá∏"
                target_flag = "üá∑üá∫"
                source_label = "Original"
                target_label = "–ü–µ—Ä–µ–≤–æ–¥"
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
            response_parts = []
            
            if self.settings['show_original']:
                response_parts.append(f"{source_flag} **{source_label}:**\n{original_text}")
            
            response_parts.append(f"{target_flag} **{target_label}:**\n{translated_text}")
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—é –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –∏ –µ—Å–ª–∏ —ç—Ç–æ —Ä—É—Å—Å–∫–∏–π —Ç–µ–∫—Å—Ç
            if self.settings['show_transliteration'] and direction == "ru-en":
                translit = self.transliterate_russian(original_text)
                response_parts.append(f"üî§ **–¢—Ä–∞–Ω—Å–ª–∏—Ç:**\n{translit}")
            
            response_parts.append("_‚ú® Google Gemini AI_")
            
            response = "\n\n".join(response_parts)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
            try:
                if self.settings['reply_in_thread'] and event.is_reply:
                    await event.reply(response, parse_mode='md')
                else:
                    await event.respond(response, parse_mode='md')
            except Exception:
                # Fallback –±–µ–∑ —Ä–∞–∑–º–µ—Ç–∫–∏
                response_plain = response.replace('**', '').replace('_', '')
                await event.respond(response_plain)
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞: {e}")
    
    def transliterate_russian(self, text: str) -> str:
        """
        –¢—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è —Ä—É—Å—Å–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
        """
        translit_dict = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd',
            '–µ': 'e', '—ë': 'yo', '–∂': 'zh', '–∑': 'z', '–∏': 'i',
            '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm', '–Ω': 'n',
            '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't',
            '—É': 'u', '—Ñ': 'f', '—Ö': 'kh', '—Ü': 'ts', '—á': 'ch',
            '—à': 'sh', '—â': 'shch', '—ä': '', '—ã': 'y', '—å': '',
            '—ç': 'e', '—é': 'yu', '—è': 'ya',
            '–ê': 'A', '–ë': 'B', '–í': 'V', '–ì': 'G', '–î': 'D',
            '–ï': 'E', '–Å': 'Yo', '–ñ': 'Zh', '–ó': 'Z', '–ò': 'I',
            '–ô': 'Y', '–ö': 'K', '–õ': 'L', '–ú': 'M', '–ù': 'N',
            '–û': 'O', '–ü': 'P', '–†': 'R', '–°': 'S', '–¢': 'T',
            '–£': 'U', '–§': 'F', '–•': 'Kh', '–¶': 'Ts', '–ß': 'Ch',
            '–®': 'Sh', '–©': 'Shch', '–™': '', '–´': 'Y', '–¨': '',
            '–≠': 'E', '–Æ': 'Yu', '–Ø': 'Ya',
        }
        
        result = []
        for char in text:
            if char in translit_dict:
                result.append(translit_dict[char])
            else:
                result.append(char)
        
        return ''.join(result)
    
    async def manual_translation(self, event, text: str):
        """–†—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥ –ø–æ –∫–æ–º–∞–Ω–¥–µ"""
        try:
            # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            if self.is_russian_text(text):
                direction = "ru-en"
                source_lang = "—Ä—É—Å—Å–∫–æ–≥–æ"
                target_lang = "–∞–Ω–≥–ª–∏–π—Å–∫–∏–π"
            elif self.is_english_text(text):
                direction = "en-ru"
                source_lang = "–∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ"
                target_lang = "—Ä—É—Å—Å–∫–æ–≥–æ"
            else:
                direction = "ru-en"
                source_lang = "–ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ —Ä—É—Å—Å–∫–æ–≥–æ"
                target_lang = "–∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ"
            
            translated = await self.get_translation(text, "", direction)
            
            if translated:
                await event.reply(
                    f"**üìù –†—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥ ({source_lang} ‚Üí {target_lang}):**\n\n"
                    f"**–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç:**\n{text}\n\n"
                    f"**–ü–µ—Ä–µ–≤–æ–¥:**\n{translated}\n\n"
                    f"_‚ú® Google Gemini AI_",
                    parse_mode='md'
                )
            else:
                await event.reply("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ API –∫–ª—é—á Gemini.")
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Ä—É—á–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞: {e}")
            await event.reply(f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: {str(e)}")
    
    async def translate_chat_history(self, event, limit: int = 5):
        """–ü–µ—Ä–µ–≤–æ–¥ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç–µ"""
        try:
            await event.reply(f"üîÑ –ü–µ—Ä–µ–≤–æ–¥ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö {limit} —Å–æ–æ–±—â–µ–Ω–∏–π...")
            
            messages = []
            async for message in self.client.iter_messages(event.chat_id, limit=limit):
                if message.text:
                    messages.append(message.text)
            
            if not messages:
                await event.reply("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞")
                return
            
            # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
            combined_text = "\n\n".join([f"{i+1}. {msg}" for i, msg in enumerate(reversed(messages))])
            
            # –ü–µ—Ä–µ–≤–æ–¥–∏–º
            translated = await self.get_translation(combined_text, "", "ru-en")
            
            if translated:
                await event.reply(
                    f"**üí¨ –ü–µ—Ä–µ–≤–æ–¥ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö {limit} —Å–æ–æ–±—â–µ–Ω–∏–π:**\n\n"
                    f"{translated}\n\n"
                    f"_‚ú® Google Gemini AI_",
                    parse_mode='md'
                )
            else:
                await event.reply("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ –∏—Å—Ç–æ—Ä–∏—é —á–∞—Ç–∞")
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞ –∏—Å—Ç–æ—Ä–∏–∏: {e}")
            await event.reply(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")
    
    async def handle_settings(self, event, args: Optional[str]):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ –Ω–∞—Å—Ç—Ä–æ–µ–∫"""
        if not args:
            settings_text = self.format_settings()
            await event.reply(settings_text, parse_mode='md')
            return
        
        args = args.strip().lower()
        
        if args == "on":
            self.settings['auto_translate'] = True
            await event.reply("‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ –≤–∫–ª—é—á–µ–Ω")
        
        elif args == "off":
            self.settings['auto_translate'] = False
            await event.reply("‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ –≤—ã–∫–ª—é—á–µ–Ω")
        
        elif args == "show":
            # –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
            settings_text = self.format_settings()
            await event.reply(settings_text, parse_mode='md')
        
        elif args.startswith("lang "):
            lang = args.split(" ", 1)[1]
            if lang in ['en', 'english', '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π']:
                self.settings['target_language'] = '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π'
                await event.reply("‚úÖ –¶–µ–ª–µ–≤–æ–π —è–∑—ã–∫: –ê–Ω–≥–ª–∏–π—Å–∫–∏–π")
            elif lang in ['ru', 'russian', '—Ä—É—Å—Å–∫–∏–π']:
                self.settings['target_language'] = '—Ä—É—Å—Å–∫–∏–π'
                await event.reply("‚úÖ –¶–µ–ª–µ–≤–æ–π —è–∑—ã–∫: –†—É—Å—Å–∫–∏–π")
            else:
                await event.reply("‚ùå –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è: en/english –∏–ª–∏ ru/russian")
        
        elif args == "formal on":
            self.settings['formal_tone'] = True
            await event.reply("‚úÖ –§–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω –ø–µ—Ä–µ–≤–æ–¥–∞ –≤–∫–ª—é—á–µ–Ω")
        
        elif args == "formal off":
            self.settings['formal_tone'] = False
            await event.reply("‚úÖ –§–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω –ø–µ—Ä–µ–≤–æ–¥–∞ –≤—ã–∫–ª—é—á–µ–Ω")
        
        elif args == "context on":
            self.settings['context_aware'] = True
            await event.reply("‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –≤–∫–ª—é—á–µ–Ω")
        
        elif args == "context off":
            self.settings['context_aware'] = False
            await event.reply("‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –≤—ã–∫–ª—é—á–µ–Ω")
        
        elif args == "translit on":
            self.settings['show_transliteration'] = True
            await event.reply("‚úÖ –¢—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è –≤–∫–ª—é—á–µ–Ω–∞")
        
        elif args == "translit off":
            self.settings['show_transliteration'] = False
            await event.reply("‚úÖ –¢—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è –≤—ã–∫–ª—é—á–µ–Ω–∞")
        
        elif args == "delete on":
            self.settings['auto_delete_original'] = True
            await event.reply("‚úÖ –ê–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ –æ—Ä–∏–≥–∏–Ω–∞–ª–∞ –≤–∫–ª—é—á–µ–Ω–æ")
        
        elif args == "delete off":
            self.settings['auto_delete_original'] = False
            await event.reply("‚úÖ –ê–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ –æ—Ä–∏–≥–∏–Ω–∞–ª–∞ –≤—ã–∫–ª—é—á–µ–Ω–æ")
        
        elif args == "reset":
            # –°–±—Ä–æ—Å –∫—ç—à–∞
            self.translation_cache.clear()
            self.language_cache.clear()
            self.conversation_history.clear()
            await event.reply("‚úÖ –ö—ç—à –∏ –∏—Å—Ç–æ—Ä–∏—è –æ—á–∏—â–µ–Ω—ã")
        
        elif args == "help":
            await self.show_help(event)
        
        else:
            await event.reply(
                "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                "‚Ä¢ `!transsettings` - –ø–æ–∫–∞–∑–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n"
                "‚Ä¢ `!transsettings on/off` - –≤–∫–ª/–≤—ã–∫–ª –∞–≤—Ç–æ-–ø–µ—Ä–µ–≤–æ–¥\n"
                "‚Ä¢ `!transsettings show` - –≤—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n"
                "‚Ä¢ `!transsettings lang en/ru` - –∏–∑–º–µ–Ω–∏—Ç—å —è–∑—ã–∫\n"
                "‚Ä¢ `!transsettings formal on/off` - —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω\n"
                "‚Ä¢ `!transsettings context on/off` - –∫–æ–Ω—Ç–µ–∫—Å—Ç\n"
                "‚Ä¢ `!transsettings translit on/off` - —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è\n"
                "‚Ä¢ `!transsettings delete on/off` - –∞–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ\n"
                "‚Ä¢ `!transsettings reset` - –æ—á–∏—Å—Ç–∏—Ç—å –∫—ç—à\n"
                "‚Ä¢ `!transsettings help` - –ø–æ–º–æ—â—å"
            )
    
    def format_settings(self) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
        settings_list = [
            f"**‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Gemini –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫:**",
            f"**API –ö–ª—é—á–∏:** Telegram Desktop (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ)",
            f"**AI –ú–æ–¥–µ–ª—å:** {self.model}",
            f"",
        ]
        
        for key, value in self.settings.items():
            if isinstance(value, bool):
                value_str = "‚úÖ –í–ö–õ" if value else "‚ùå –í–´–ö–õ"
            else:
                value_str = str(value)
            settings_list.append(f"**{key}:** {value_str}")
        
        return "\n".join(settings_list)
    
    async def show_stats(self, event):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
        uptime = datetime.now() - self.stats['start_time']
        days = uptime.days
        hours, remainder = divmod(uptime.seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        
        last_trans = self.stats['last_translation']
        last_time = last_trans.strftime("%Y-%m-%d %H:%M:%S") if last_trans else "–Ω–∏–∫–æ–≥–¥–∞"
        
        cache_hit_rate = (self.stats['cache_hits'] / self.stats['total_translations'] * 100) if self.stats['total_translations'] > 0 else 0
        
        stats_text = (
            f"**üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ Gemini –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫:**\n\n"
            f"**–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**\n"
            f"‚Ä¢ –í—Å–µ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–æ–≤: **{self.stats['total_translations']}**\n"
            f"‚Ä¢ –°–∏–º–≤–æ–ª–æ–≤ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ: **{self.stats['total_characters']:,}**\n"
            f"‚Ä¢ –ó–∞–ø—Ä–æ—Å–æ–≤ –∫ Gemini API: **{self.stats['api_calls']}**\n"
            f"‚Ä¢ –û—à–∏–±–æ–∫: **{self.stats['errors']}**\n"
            f"‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø–µ—Ä–µ–≤–æ–¥: **{last_time}**\n\n"
            
            f"**–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:**\n"
            f"‚Ä¢ –ü–æ–ø–∞–¥–∞–Ω–∏–π –≤ –∫—ç—à: **{self.stats['cache_hits']}**\n"
            f"‚Ä¢ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∫—ç—à–∞: **{cache_hit_rate:.1f}%**\n"
            f"‚Ä¢ –†–∞–∑–º–µ—Ä –∫—ç—à–∞: **{len(self.translation_cache)}/{self.settings['cache_size']}**\n"
            f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö —á–∞—Ç–æ–≤: **{len(self.conversation_history)}**\n\n"
            
            f"**–°–∏—Å—Ç–µ–º–∞:**\n"
            f"‚Ä¢ –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: **{days}–¥ {hours}—á {minutes}–º {seconds}—Å**\n"
            f"‚Ä¢ API –∫–ª—é—á–∏: **{self.stats['api_keys_used']}**\n"
            f"‚Ä¢ –ú–æ–¥–µ–ª—å AI: **{self.model}**\n"
            f"‚Ä¢ –°—Ç–∞—Ç—É—Å: **{'‚úÖ –ê–∫—Ç–∏–≤–µ–Ω' if self.settings['auto_translate'] else '‚è∏Ô∏è –ù–∞ –ø–∞—É–∑–µ'}**"
        )
        
        await event.reply(stats_text, parse_mode='md')
    
    async def show_help(self, event):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É"""
        help_text = (
            f"**ü§ñ Gemini –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ –¥–ª—è Telegram**\n\n"
            f"**–í–µ—Ä—Å–∏—è:** –° —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ API –∫–ª—é—á–∞–º–∏ Telegram Desktop\n"
            f"**API ID:** {FIXED_API_ID}\n"
            f"**API Hash:** {FIXED_API_HASH[:8]}...\n\n"
            
            f"**üöÄ –û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:**\n"
            f"‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ —Ä—É—Å—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π\n"
            f"‚Ä¢ –ü–µ—Ä–µ–≤–æ–¥ –≤—Ö–æ–¥—è—â–∏—Ö –∞–Ω–≥–ª–∏–π—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ —Ä—É—Å—Å–∫–∏–π\n"
            f"‚Ä¢ –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ —Å —É—á–µ—Ç–æ–º –∏—Å—Ç–æ—Ä–∏–∏\n"
            f"‚Ä¢ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤\n"
            f"‚Ä¢ –¢—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è —Ä—É—Å—Å–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞\n"
            f"‚Ä¢ –§–æ—Ä–º–∞–ª—å–Ω—ã–π/–Ω–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Å—Ç–∏–ª—å\n\n"
            
            f"**üõ†Ô∏è –ö–æ–º–∞–Ω–¥—ã:**\n"
            f"‚Ä¢ –ü—Ä–æ—Å—Ç–æ –ø–∏—à–∏—Ç–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º ‚Üí –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥\n"
            f"‚Ä¢ `!tr [—Ç–µ–∫—Å—Ç]` –∏–ª–∏ `!translate [—Ç–µ–∫—Å—Ç]` - —Ä—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥\n"
            f"‚Ä¢ `!transsettings` - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏\n"
            f"‚Ä¢ `!trstats` - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞–±–æ—Ç—ã\n"
            f"‚Ä¢ `!trchat [—á–∏—Å–ª–æ]` - –ø–µ—Ä–µ–≤–æ–¥ –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞\n"
            f"‚Ä¢ `!trhelp` - —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n\n"
            
            f"**‚öôÔ∏è –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:**\n"
            f"‚Ä¢ `!transsettings on/off` - –≤–∫–ª/–≤—ã–∫–ª –∞–≤—Ç–æ-–ø–µ—Ä–µ–≤–æ–¥\n"
            f"‚Ä¢ `!transsettings lang en/ru` - —Ü–µ–ª–µ–≤–æ–π —è–∑—ã–∫\n"
            f"‚Ä¢ `!transsettings formal on/off` - —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–æ–Ω\n"
            f"‚Ä¢ `!transsettings context on/off` - –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥\n"
            f"‚Ä¢ `!transsettings translit on/off` - —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è\n"
            f"‚Ä¢ `!transsettings delete on/off` - –∞–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ –æ—Ä–∏–≥–∏–Ω–∞–ª–∞\n\n"
            
            f"**üîß –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:**\n"
            f"‚Ä¢ **AI –ú–æ–¥–µ–ª—å:** {self.model}\n"
            f"‚Ä¢ **API:** Google Gemini Pro\n"
            f"‚Ä¢ **Telegram API:** Telegram Desktop keys\n"
            f"‚Ä¢ **–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫:** Darkar25 System\n"
            f"‚Ä¢ **–í–µ—Ä—Å–∏—è:** 2.0 Fixed API Edition"
        )
        
        await event.reply(help_text, parse_mode='md')


# ==================== –§–£–ù–ö–¶–ò–Ø –°–û–ó–î–ê–ù–ò–Ø –ö–õ–ò–ï–ù–¢–ê ====================

def create_telegram_client(session_name: str = "gemini_translator_fixed"):
    """
    –°–æ–∑–¥–∞–µ—Ç –∫–ª–∏–µ–Ω—Ç Telegram —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ API –∫–ª—é—á–∞–º–∏
    
    Args:
        session_name: –ò–º—è —Å–µ—Å—Å–∏–∏
        
    Returns:
        TelegramClient: –ö–ª–∏–µ–Ω—Ç Telethon
    """
    logger.info(f"–°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞ —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∫–ª—é—á–∞–º–∏ Telegram Desktop")
    logger.info(f"API ID: {FIXED_API_ID}")
    logger.info(f"API Hash: {FIXED_API_HASH[:8]}...")
    logger.info(f"–ò–º—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è: {FIXED_APP_NAME}")
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∏–µ–Ω—Ç —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∫–ª—é—á–∞–º–∏
    client = TelegramClient(
        session=session_name,
        api_id=FIXED_API_ID,
        api_hash=FIXED_API_HASH,
        app_version="4.16.5",
        device_model="Desktop",
        system_version="Windows 10"
    )
    
    return client


# ==================== –§–£–ù–ö–¶–ò–Ø –†–ï–ì–ò–°–¢–†–ê–¶–ò–ò –î–õ–Ø –°–ò–°–¢–ï–ú –ú–û–î–£–õ–ï–ô ====================

def register(bot=None):
    """
    –§—É–Ω–∫—Ü–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –º–æ–¥—É–ª—è –¥–ª—è —Å–∏—Å—Ç–µ–º –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥—É–ª–µ–π
    
    Args:
        bot: –û–±—ä–µ–∫—Ç –±–æ—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        
    Returns:
        dict: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–æ–¥—É–ª–µ –∏–ª–∏ bool —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    """
    try:
        logger.info("–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–æ–¥—É–ª—è Gemini Translator —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∫–ª—é—á–∞–º–∏")
        
        # –°–æ–∑–¥–∞–µ–º –∫–ª–∏–µ–Ω—Ç
        client = create_telegram_client()
        
        # –ü–æ–ª—É—á–∞–µ–º Gemini API –∫–ª—é—á –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
        gemini_key = os.getenv('GEMINI_API_KEY')
        
        if not gemini_key:
            logger.error("–¢—Ä–µ–±—É–µ—Ç—Å—è GEMINI_API_KEY –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
            return {
                'success': False,
                'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è GEMINI_API_KEY –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è'
            }
        
        # –°–æ–∑–¥–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫
        translator = GeminiTranslator(client, gemini_key)
        
        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω –æ–±—ä–µ–∫—Ç –±–æ—Ç–∞, —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫–∏
        if bot is not None:
            bot.gemini_translator = translator
            bot.gemini_client = client
        
        logger.info("‚úÖ –ú–æ–¥—É–ª—å Gemini Translator —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω")
        
        return {
            'success': True,
            'name': 'Gemini Translator',
            'version': '2.0',
            'author': 'Darkar25',
            'description': '–ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Google Gemini AI',
            'api_keys': 'Telegram Desktop Fixed',
            'features': ['auto-translate', 'context-aware', 'caching', 'multi-language']
        }
        
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –º–æ–¥—É–ª—è: {e}")
        return {
            'success': False,
            'error': str(e)
        }


# ==================== –û–°–ù–û–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ó–ê–ü–£–°–ö–ê ====================

async def main():
    """
    –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –¥–ª—è —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    """
    print("=" * 60)
    print("üöÄ Gemini Translator - Telegram Desktop Fixed API Edition")
    print("=" * 60)
    print(f"üì± API ID: {FIXED_API_ID}")
    print(f"üîë API Hash: {FIXED_API_HASH[:8]}...")
    print(f"ü§ñ AI –ú–æ–¥–µ–ª—å: gemini-1.5-pro-latest")
    print("=" * 60)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º Gemini API –∫–ª—é—á
    gemini_api_key = os.getenv('GEMINI_API_KEY')
    
    if not gemini_api_key:
        print("\n‚ùå –û–®–ò–ë–ö–ê: –ù–µ –Ω–∞–π–¥–µ–Ω GEMINI_API_KEY!")
        print("–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è:")
        print("  export GEMINI_API_KEY='–≤–∞—à_–∫–ª—é—á_–∑–¥–µ—Å—å'")
        print("\n–ü–æ–ª—É—á–∏—Ç—å –∫–ª—é—á –º–æ–∂–Ω–æ –Ω–∞: https://makersuite.google.com/app/apikey")
        return
    
    print(f"üîê Gemini API Key: {gemini_api_key[:8]}...")
    print("=" * 60)
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∏–µ–Ω—Ç
    client = create_telegram_client()
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫
    translator = GeminiTranslator(client, gemini_api_key)
    
    try:
        # –ó–∞–ø—É—Å–∫–∞–µ–º –∫–ª–∏–µ–Ω—Ç
        await client.start()
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
        me = await client.get_me()
        
        print(f"\n‚úÖ –£—Å–ø–µ—à–Ω—ã–π –∑–∞–ø—É—Å–∫!")
        print(f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {me.first_name} (@{me.username})")
        print(f"üÜî ID: {me.id}")
        print(f"üìû –ù–æ–º–µ—Ä: {me.phone}")
        print(f"ü§ñ –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫: –í–∫–ª—é—á–µ–Ω")
        print(f"üéØ –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –†—É—Å—Å–∫–∏–π ‚Üí –ê–Ω–≥–ª–∏–π—Å–∫–∏–π")
        print(f"üíæ –ö—ç—à: {translator.settings['cache_size']} –∑–∞–ø–∏—Å–µ–π")
        print("\n" + "=" * 60)
        print("üìù –ö–æ–º–∞–Ω–¥—ã:")
        print("  ‚Ä¢ –ü—Ä–æ—Å—Ç–æ –ø–∏—à–∏—Ç–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥")
        print("  ‚Ä¢ !tr [—Ç–µ–∫—Å—Ç] - —Ä—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥")
        print("  ‚Ä¢ !transsettings - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏")
        print("  ‚Ä¢ !trstats - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
        print("  ‚Ä¢ !trhelp - –ø–æ–º–æ—â—å")
        print("=" * 60)
        print("\nüí° –°–æ–≤–µ—Ç: –î–ª—è –≤—ã—Ö–æ–¥–∞ –Ω–∞–∂–º–∏—Ç–µ Ctrl+C")
        print("=" * 60)
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª
        await client.run_until_disconnected()
        
    except Exception as e:
        print(f"\n‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: {e}")
        print("\n–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:")
        print("1. –ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø—Ä–∏ –≤—Ö–æ–¥–µ")
        print("2. –ü—Ä–æ–±–ª–µ–º—ã —Å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ–º")
        print("3. –ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è —Å–µ—Å—Å–∏—è")
        print("\n–†–µ—à–µ–Ω–∏–µ: –£–¥–∞–ª–∏—Ç–µ —Ñ–∞–π–ª —Å–µ—Å—Å–∏–∏ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞")
    finally:
        print("\nüëã –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã Gemini Translator...")


# ==================== –¢–û–ß–ö–ê –í–•–û–î–ê ====================

if __name__ == '__main__':
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–ø—É—â–µ–Ω –ª–∏ –≤ —Ä–µ–∂–∏–º–µ –º–æ–¥—É–ª—è
    if len(sys.argv) > 1 and sys.argv[1] == '--register':
        # –†–µ–∂–∏–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –º–æ–¥—É–ª—è
        result = register()
        print(json.dumps(result, indent=2, ensure_ascii=False))
    else:
        # –û–±—ã—á–Ω—ã–π –∑–∞–ø—É—Å–∫
        try:
            asyncio.run(main())
        except KeyboardInterrupt:
            print("\n\nüëã –í—ã—Ö–æ–¥ –ø–æ –∑–∞–ø—Ä–æ—Å—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
        except Exception as e:
            print(f"\n‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
