#!/usr/bin/env python3
"""
Gemini Translator –¥–ª—è Telegram
–ú–æ–¥—É–ª—å –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞ —Ä—É—Å—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π
–ê–≤—Ç–æ—Ä: @userkastyan
"""

import os
import sys
import asyncio
import hashlib
import json
from datetime import datetime
from typing import Optional, Dict, List
import aiohttp
from telethon import TelegramClient, events
import logging

# ==================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ====================
API_ID = 2040
API_HASH = "b18441a1ff607e10a989891a5462e627"
APP_NAME = "Telegram Desktop"
# ======================================================

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

class GeminiTranslator:
    """–ö–ª–∞—Å—Å –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ Google Gemini AI"""
    
    def __init__(self, client: TelegramClient, api_key: str):
        self.client = client
        self.api_key = api_key
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏
        self.settings = {
            'auto_translate': True,
            'target_language': 'english',
            'cache_enabled': True,
            'cache_size': 500,
            'show_original': True,
        }
        
        # –ö—ç—à
        self.cache: Dict[str, str] = {}
        self.stats = {
            'translations': 0,
            'cache_hits': 0,
            'errors': 0,
        }
        
        # URL API
        self.base_url = "https://generativelanguage.googleapis.com/v1beta/models"
        self.model = "gemini-1.5-pro-latest"
        
        self.setup_handlers()
        logger.info("Gemini Translator –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    def setup_handlers(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π"""
        
        @self.client.on(events.NewMessage(outgoing=True))
        async def handler(event):
            if not self.settings['auto_translate']:
                return
            
            text = event.message.message
            if not text or len(text.strip()) < 2:
                return
            
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–æ–º–∞–Ω–¥—ã
            if text.startswith(('/', '!', '.')):
                return
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä—É—Å—Å–∫–∏–π —Ç–µ–∫—Å—Ç
            if self.is_russian(text):
                await self.translate_and_reply(event, text)
        
        @self.client.on(events.NewMessage(pattern='^!tr\s+(.+)$'))
        async def manual_handler(event):
            text = event.pattern_match.group(1)
            if text:
                await self.manual_translation(event, text)
        
        @self.client.on(events.NewMessage(pattern='^!trstats$'))
        async def stats_handler(event):
            await self.show_stats(event)
        
        @self.client.on(events.NewMessage(pattern='^!trhelp$'))
        async def help_handler(event):
            await self.show_help(event)
    
    def is_russian(self, text: str) -> bool:
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç —Ä—É—Å—Å–∫–∏–º"""
        ru_chars = sum(1 for c in text.lower() if '–∞' <= c <= '—è' or c == '—ë')
        en_chars = sum(1 for c in text.lower() if 'a' <= c <= 'z')
        
        if ru_chars + en_chars == 0:
            return False
        
        return ru_chars / (ru_chars + en_chars) > 0.6
    
    async def call_gemini_api(self, text: str) -> Optional[str]:
        """–í—ã–∑–æ–≤ Gemini API"""
        url = f"{self.base_url}/{self.model}:generateContent?key={self.api_key}"
        
        prompt = f"""–ü–µ—Ä–µ–≤–µ–¥–∏ —Å–ª–µ–¥—É—é—â–∏–π —Ä—É—Å—Å–∫–∏–π —Ç–µ–∫—Å—Ç –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π:

{text}

–ü–µ—Ä–µ–≤–æ–¥:"""
        
        payload = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {
                "temperature": 0.1,
                "maxOutputTokens": 1000,
            }
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=payload, timeout=30) as response:
                    if response.status == 200:
                        data = await response.json()
                        if 'candidates' in data:
                            candidate = data['candidates'][0]
                            if 'content' in candidate:
                                return candidate['content']['parts'][0]['text'].strip()
        except Exception as e:
            logger.error(f"API error: {e}")
        
        return None
    
    async def translate_and_reply(self, event, original_text: str):
        """–ü–µ—Ä–µ–≤–æ–¥ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        cache_key = hashlib.md5(original_text.encode()).hexdigest()
        if self.settings['cache_enabled'] and cache_key in self.cache:
            translated = self.cache[cache_key]
            self.stats['cache_hits'] += 1
        else:
            translated = await self.call_gemini_api(original_text)
            if translated and self.settings['cache_enabled']:
                self.cache[cache_key] = translated
                if len(self.cache) > self.settings['cache_size']:
                    self.cache.pop(next(iter(self.cache)))
        
        if translated:
            self.stats['translations'] += 1
            
            response = "üá∫üá∏ **Translation:**\n"
            response += f"{translated}\n\n"
            
            if self.settings['show_original']:
                response += "üá∑üá∫ **Original:**\n"
                response += f"{original_text}\n\n"
            
            response += "_Powered by Google Gemini AI_"
            
            await event.respond(response, parse_mode='md')
        else:
            self.stats['errors'] += 1
    
    async def manual_translation(self, event, text: str):
        """–†—É—á–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥"""
        translated = await self.call_gemini_api(text)
        if translated:
            response = f"**Manual Translation:**\n\n"
            response += f"**Original:** {text}\n\n"
            response += f"**Translation:** {translated}\n\n"
            response += "_Google Gemini AI_"
            await event.reply(response, parse_mode='md')
        else:
            await event.reply("‚ùå Translation failed")
    
    async def show_stats(self, event):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
        stats_text = f"""
üìä **Translation Statistics:**

‚Ä¢ Total translations: {self.stats['translations']}
‚Ä¢ Cache hits: {self.stats['cache_hits']}
‚Ä¢ Errors: {self.stats['errors']}
‚Ä¢ Cache size: {len(self.cache)}/{self.settings['cache_size']}

**Settings:**
‚Ä¢ Auto-translate: {'‚úÖ ON' if self.settings['auto_translate'] else '‚ùå OFF'}
‚Ä¢ Show original: {'‚úÖ ON' if self.settings['show_original'] else '‚ùå OFF'}
‚Ä¢ Cache: {'‚úÖ ON' if self.settings['cache_enabled'] else '‚ùå OFF'}

_Author: @userkastyan_
"""
        await event.reply(stats_text, parse_mode='md')
    
    async def show_help(self, event):
        """–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–º–æ—â—å"""
        help_text = """
ü§ñ **Gemini Translator Bot**
_Author: @userkastyan_

**Commands:**
‚Ä¢ Just type in Russian ‚Üí auto-translate to English
‚Ä¢ `!tr [text]` ‚Üí manual translation
‚Ä¢ `!trstats` ‚Üí show statistics
‚Ä¢ `!trhelp` ‚Üí show this help

**Features:**
‚Ä¢ Automatic Russian ‚Üí English translation
‚Ä¢ Caching for faster responses
‚Ä¢ Manual translation command
‚Ä¢ Statistics tracking

**Powered by Google Gemini AI**
"""
        await event.reply(help_text, parse_mode='md')

class GeminiTranslatorModule:
    """
    –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –º–æ–¥—É–ª—è –¥–ª—è Heroku
    –≠—Ç–æ—Ç –∫–ª–∞—Å—Å –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å–∏—Å—Ç–µ–º–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥—É–ª–µ–π
    """
    
    def __init__(self):
        self.name = "GeminiTranslator"
        self.version = "2.0"
        self.author = "@userkastyan"
        self.description = "Automatic Russian to English translation using Google Gemini AI"
        
        self.bot = None
        self.client = None
        self.translator = None
        
        logger.info(f"Module {self.name} v{self.version} by {self.author} initialized")
    
    async def start(self):
        """–ó–∞–ø—É—Å–∫ –º–æ–¥—É–ª—è"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º API –∫–ª—é—á
            gemini_key = os.getenv('GEMINI_API_KEY')
            if not gemini_key:
                raise ValueError("GEMINI_API_KEY environment variable is required")
            
            # –°–æ–∑–¥–∞–µ–º –∫–ª–∏–µ–Ω—Ç Telegram
            self.client = TelegramClient(
                session='gemini_translator',
                api_id=API_ID,
                api_hash=API_HASH
            )
            
            # –°–æ–∑–¥–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫
            self.translator = GeminiTranslator(self.client, gemini_key)
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –∫–ª–∏–µ–Ω—Ç
            await self.client.start()
            
            me = await self.client.get_me()
            logger.info(f"Bot started as: {me.first_name} (@{me.username})")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to start module: {e}")
            return False
    
    async def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ–¥—É–ª—è"""
        if self.client:
            await self.client.disconnect()
        logger.info("Module stopped")
    
    def get_info(self):
        """–ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–æ–¥—É–ª–µ"""
        return {
            'name': self.name,
            'version': self.version,
            'author': self.author,
            'description': self.description,
            'status': 'running' if self.client else 'stopped'
        }

# ==================== –§–£–ù–ö–¶–ò–Ø –†–ï–ì–ò–°–¢–†–ê–¶–ò–ò ====================
# –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–ê –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥—É–ª—è –≤ Heroku

async def register_module():
    """
    –§—É–Ω–∫—Ü–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –º–æ–¥—É–ª—è
    –î–æ–ª–∂–Ω–∞ –≤–µ—Ä–Ω—É—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–ª–∞—Å—Å–∞, –∞ –Ω–µ —Å–ª–æ–≤–∞—Ä—å
    """
    try:
        module = GeminiTranslatorModule()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ API –∫–ª—é—á–∞
        if not os.getenv('GEMINI_API_KEY'):
            logger.error("GEMINI_API_KEY not found in environment variables")
            logger.error("Please set: heroku config:set GEMINI_API_KEY=your_key_here")
            return None
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –º–æ–¥—É–ª—å –≤ —Ñ–æ–Ω–µ
        asyncio.create_task(module.start())
        
        logger.info(f"‚úÖ Module '{module.name}' registered successfully")
        return module
        
    except Exception as e:
        logger.error(f"‚ùå Failed to register module: {e}")
        return None

# –°–æ–∑–¥–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –º–æ–¥—É–ª—è
_module_instance = None

def register():
    """
    –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –¥–ª—è Heroku
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–ª–∞—Å—Å–∞ Module, –∞ –Ω–µ —Å–ª–æ–≤–∞—Ä—å
    """
    global _module_instance
    
    try:
        # –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –º–æ–¥—É–ª—è
        _module_instance = GeminiTranslatorModule()
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º API –∫–ª—é—á
        if not os.getenv('GEMINI_API_KEY'):
            print("ERROR: GEMINI_API_KEY environment variable is required!")
            print("Set it with: heroku config:set GEMINI_API_KEY=your_key")
            return None
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –º–æ–¥—É–ª—å –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        def run_module():
            asyncio.run(_module_instance.start())
        
        import threading
        thread = threading.Thread(target=run_module, daemon=True)
        thread.start()
        
        print(f"‚úÖ Gemini Translator Module registered successfully!")
        print(f"   Name: {_module_instance.name}")
        print(f"   Version: {_module_instance.version}")
        print(f"   Author: {_module_instance.author}")
        print(f"   Waiting for initialization...")
        
        return _module_instance
        
    except Exception as e:
        print(f"‚ùå Failed to register module: {e}")
        return None

# ==================== –î–õ–Ø –°–ê–ú–û–°–¢–û–Ø–¢–ï–õ–¨–ù–û–ì–û –ó–ê–ü–£–°–ö–ê ====================

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞"""
    print("=" * 50)
    print("Gemini Translator Telegram Bot")
    print(f"Author: @userkastyan")
    print("=" * 50)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º API –∫–ª—é—á
    api_key = os.getenv('GEMINI_API_KEY')
    if not api_key:
        print("ERROR: GEMINI_API_KEY environment variable is required!")
        print("Export it: export GEMINI_API_KEY='your_key_here'")
        print("Or create .env file with GEMINI_API_KEY=your_key")
        return
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∏–µ–Ω—Ç
    client = TelegramClient(
        session='gemini_bot_session',
        api_id=API_ID,
        api_hash=API_HASH
    )
    
    # –°–æ–∑–¥–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫
    translator = GeminiTranslator(client, api_key)
    
    try:
        await client.start()
        
        me = await client.get_me()
        print(f"‚úÖ Bot started as: {me.first_name} (@{me.username})")
        print(f"üì± Phone: {me.phone}")
        print("\n" + "=" * 50)
        print("Bot is running! Commands:")
        print("‚Ä¢ Type in Russian ‚Üí auto-translate to English")
        print("‚Ä¢ !tr [text] ‚Üí manual translation")
        print("‚Ä¢ !trstats ‚Üí statistics")
        print("‚Ä¢ !trhelp ‚Üí help")
        print("=" * 50)
        print("\nPress Ctrl+C to stop")
        
        await client.run_until_disconnected()
        
    except KeyboardInterrupt:
        print("\n\nüëã Bot stopped by user")
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
    finally:
        await client.disconnect()

if __name__ == "__main__":
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∂–∏–º –∑–∞–ø—É—Å–∫–∞
    if len(sys.argv) > 1 and sys.argv[1] == "--register":
        # –†–µ–∂–∏–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –º–æ–¥—É–ª—è
        result = register()
        if result:
            print("Module registered successfully!")
            # –î–µ—Ä–∂–∏–º –ø—Ä–æ–≥—Ä–∞–º–º—É –∑–∞–ø—É—â–µ–Ω–Ω–æ–π
            try:
                import time
                while True:
                    time.sleep(1)
            except KeyboardInterrupt:
                print("\nExiting...")
        else:
            print("Failed to register module")
    else:
        # –û–±—ã—á–Ω—ã–π –∑–∞–ø—É—Å–∫
        asyncio.run(main())
